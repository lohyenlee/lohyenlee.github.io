<!DOCTYPE html>
<html lang="en">

<head>
  <title>Marble game ....Yen Lee Loh </title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
  <style>
    #info {
      position: absolute;
      top: 36px;
      width: 100%;
      text-align: center;
      color: white;
      z-index: 100;
      display: block;
      font-family: monospace;
      font-size: 36px;
    }
  </style>

</head>

<body>

  <div id="info">Press Space to launch</div>


  <script type="module">
    //================================
    // SOUND 
    //================================
    var mySound;   // global variable
    initSounds();  // called as part of module
    function initSounds() { mySound = new sound("Tink.mp3"); }
    function sound(src) {
      this.sound = document.createElement("audio");
      this.sound.src = src;
      this.sound.setAttribute("preload", "auto");
      this.sound.setAttribute("controls", "none");
      this.sound.style.display = "none";
      document.body.appendChild(this.sound);
      this.play = function () { this.sound.play(); }
      this.stop = function () { this.sound.pause(); }
    }

    //================================
    // GRAPHICS 
    //================================
    //-------- Load THREE.js from CDN
    //import * as THREE from 'https://cdn.skypack.dev/three@0.129.0';
    //import { FlyControls } from 'https://cdn.skypack.dev/three@0.129.0/examples/jsm/controls/FlyControls.js';
    //-------- Load THREE.js from current directory on a HTTP server (python3 -m http.server 8000)
    import * as THREE from './three.module.js';
    import { FlyControls } from './FlyControls.js';

    let camera, scene, renderer, controls, group;
    let msg;
    let meshBall;
    let woodTexture, wood5;
    const mouse = new THREE.Vector2();
    const raycaster = new THREE.Raycaster();
    const clock = new THREE.Clock();
    const selectables = [];
    const imax = 10;
    const jmax = 10;

    init();



    function myPrismGeometry(nSides = 6, radius = 1, thickness = 1, extrudeSteps = 1, rotationAngle = 0) {
      //-------- Construct regular polygon
      const points = [];
      for (let n = 0; n < nSides; ++n) {
        let phi = 2 * Math.PI * n / nSides + rotationAngle;
        points.push(new THREE.Vector2(radius * Math.cos(phi), radius * Math.sin(phi)));
      }
      const shape = new THREE.Shape(points);
      //-------- Extrude along straight line
      const extrudeSettings = {
        steps: extrudeSteps,
        depth: thickness,
        bevelEnabled: false
      };
      return new THREE.ExtrudeGeometry(shape, extrudeSettings);
    }
    var hexagonGeometry; // must be var
    var hexagonMaterial;
    function addHexagonOnGround(i, j) {
      let material = new THREE.MeshPhongMaterial({ color: 0x333333 });
      switch ((i + j) % 3) {
        case 0: material.color.setHex(0x999999); break;
        case 1: material.color.setHex(0x888888); break;
        default: material.color.setHex(0x777777);
      }
      const mesh = new THREE.Mesh(hexagonGeometry, material);
      [mesh.position.x, mesh.position.y] = cartFromHex(i, j);
      mesh.position.z = -1;
      mesh.receiveShadow = true;
      scene.add(mesh);
      return mesh;
    }
    function addHexagon(i, j) {
      //hexagonMaterial = new THREE.MeshPhongMaterial({ color: 0x996633 });
      hexagonMaterial = new THREE.MeshPhongMaterial({ color: 0x999999 });
      hexagonMaterial.map = woodTexture;

      const mesh = new THREE.Mesh(hexagonGeometry, hexagonMaterial);
      [mesh.position.x, mesh.position.y] = cartFromHex(i, j);
      mesh.position.z = 0;
      scene.add(mesh);
      return mesh;
    }

    function init() {
      //-------- PRELOADER STUFF
      const loader = new THREE.TextureLoader();
      woodTexture = loader.load('wood2.jpg');
      wood5 = loader.load('marble1.jpg');
      hexagonGeometry = myPrismGeometry(6, 1.0 / Math.sqrt(3), 1, 1, Math.PI / 6);
      //-------- IMPORTANT PARAMETERS
      let xCenter = imax / 2 - 0.5 * jmax / 2;
      let yCenter = 0.86602540378 * jmax / 2;
      let camDist = imax * 1.;
      //-------- SCENE, CAMERA, LIGHTS
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x111111);
      camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 1000);
      camera.position.set(0, 0, 100); camera.lookAt(0, 0, 0); // top view
      camera.position.set(xCenter, -.2 * camDist, .7 * camDist); camera.lookAt(xCenter, yCenter, 0); // side view

      // camera = new THREE.OrthographicCamera(
      //   -5, 5,
      //   5*window.innerHeight/window.innerWidth, -5*window.innerHeight/window.innerWidth,
      //   1, 1000);
      // camera.position.set(0, 0, 100);

      scene.add(new THREE.AmbientLight(0x333333));
      {
        const light = new THREE.DirectionalLight(0xCCCCCC, 1.0);
        light.position.set(0, 0, 0);
        light.target.position.set(1, 1, -1);
        light.castShadow = true;
        light.shadow.camera.near = .1;
        light.shadow.camera.far = 1000;
        light.shadow.mapSize.width = 1024;
        light.shadow.mapSize.height = 1024;
        scene.add(light); scene.add(light.target);
      }
      {
        const light = new THREE.SpotLight(0xFFFFFF, 0.25);
        light.position.set(0, 0, 12);
        light.target.position.set(2, 2, 0);//(xCenter, yCenter, 0);
        light.angle = Math.PI / 180 * 15;
        light.castShadow = true;
        light.shadow.camera.near = .1;
        light.shadow.camera.far = 1000;
        light.shadow.mapSize.width = 1024;
        light.shadow.mapSize.height = 1024;
        scene.add(light); scene.add(light.target);
      }
      //-------- REAL BASEPLATE
      // {
      //   const geometry = new THREE.PlaneGeometry(30, 30); // this is centered on (0,0,0);
      //   const material = new THREE.MeshPhongMaterial({ color: 0x339933, side: THREE.DoubleSide });
      //   const mesh = new THREE.Mesh(geometry, material);
      //   mesh.position.z = -1;
      //   //mesh.receiveShadow = true;
      //   scene.add(mesh);
      // }
      //-------- GROUND (PLAYING FIELD)
      {
        const si = `
000011111
000111111
001111111
011111111
111101111
111111110
111111100
111111000
111110000
        `.trim().split('\n');
        let imax = si.length;
        let jmax = Math.max(...(si.map(el => el.length)));
        for (let i = 0; i < imax; ++i) {
          for (let j = 0; j < jmax; ++j) {
            if (si[i].charAt(j) == '1') {
              //addHexagonOnGround(i, j);
              let mesh = addHexagonOnGround(j, imax - 1 - i);
              selectables.push(mesh);
            }
          }
        }
      }
      //-------- OBSTACLES
      {
        // need to store this info as ground[i,j] = 1 or 0 depending on whether hex is present
        const si = `
0000000
0010000
0000000
0000000
0000000
0000000
0000000
        `.trim().split('\n');
        let imax = si.length;
        let jmax = Math.max(...(si.map(el => el.length)));
        for (let i = 0; i < imax; ++i) {
          for (let j = 0; j < jmax; ++j) {
            if (si[i].charAt(j) == '1') {
              //addHexagonOnGround(i, j);
              let mesh = addHexagon(j, imax - 1 - i);
              selectables.push(mesh);
            }
          }
        }
      }
      //-------- BALL
      meshBall = new THREE.Mesh(
        new THREE.SphereGeometry(0.5, 32, 32),
        new THREE.MeshPhongMaterial()
      );
      meshBall.material.map = wood5; //loader.load('earthmap1k.jpg');
      meshBall.position.set(2, 2, .5);
      meshBall.castShadow = true;
      scene.add(meshBall);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFShadowMap;

      controls = new FlyControls(camera, renderer.domElement);
      controls.movementSpeed = 10;
      controls.domElement = renderer.domElement;
      controls.rollSpeed = Math.PI / 24;
      controls.autoForward = false;
      controls.dragToLook = true;

      document.body.insertBefore(renderer.domElement, document.body.firstChild);
      window.addEventListener('resize', onWindowResize);
      window.addEventListener('keydown', onKeyDown);
      window.addEventListener('mousedown', onMouseDown);
      //document.addEventListener('click', onClick);
      //requestAnimationFrame(animate);
      renderer.render(scene, camera);
    }





    var vx = 1; // marble velocity
    var vy = 0;
    var vz = 0; // 0 except if falling
    var r = .5;  // marble radius

    function cartFromHex(u, v) {
      return [u - 0.5 * v, 0.86602540378 * v];
    }
    function hexFromCart(x, y) {
      return [x + 0.5773502691896258 * y, 1.1547005383792517 * y];
    }


    function launchBall() {
      let x, y;
      [x, y] = cartFromHex(0, 3);
      meshBall.position.set(x, y, .5);
      vx = 3; //1;
      vy = 0;
      vz = 0;
      requestAnimationFrame(animate);
    }


    function animate(timeCurrent) {
      let shouldRequestFrame = true;
      const dt = clock.getDelta(); // time in seconds since last call to clock.getDelta()

      //-------- Rolling without slipping
      let x = meshBall.position.x;
      let y = meshBall.position.y;
      let z = meshBall.position.z;
      x += vx * dt;
      y += vy * dt;
      z += vz * dt;
      //-------- Check for collisions?
      //if (x < 1) { vx = +1; mySound.play(); }
      // if .... we are at intersction,
      // look ahead ; if there is a hexagon ahead, reflect back
      // ilook to the sides; if there is hex either side (but not both), reflect at 120 deg angle
      // 

      //-------- Check for falling off edge
      let i, j, i0, j0, distFromSite;
      [i, j] = hexFromCart(x, y);
      i0 = Math.round(i);
      j0 = Math.round(j);
      distFromSite = Math.sqrt((i-i0)**2 + (j-j0)**2);
      msg = "i = " + i + " j = " + j; info.innerHTML = msg;

      // uhhh we are testing for a hole at (3,3)


      if (z >= 0.5 && 
      (i0 == 3 && j0 == 3 && distFromSite < .05 || i0 < 0 || i0 >= imax || j0 < 0 || j0 > jmax)) {
        vx = vy = 0; vz = -0.001;
        mySound.play();
      }
      //if (x > imax / 2) { vx = vy = 0; vz = -0.001; }// mySound.play(); }

      if (vz < 0) { vz -= 100.0 * dt; } // ball is falling
      if (z < -3) { vz = 0; shouldRequestFrame = false; } // ball is in the abyss; stop anim
      meshBall.position.x = x;
      meshBall.position.y = y;
      meshBall.position.z = z;
      let vv = new THREE.Vector3(-vy, vx, 0); 
      meshBall.rotateOnWorldAxis(vv.normalize(), dt * vv.length() / r);

      //-------- Boilerplate
      controls.update(dt);
      renderer.render(scene, camera);
      if (shouldRequestFrame) requestAnimationFrame(animate);
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.render(scene, camera);
    }

    function onKeyDown(event) {
      switch (event.keyCode) {
        //case 64 + : vx = 0; vy = +1; break;
        case 64 + 9: vx = 0; vy = +1; break;
        case 64 + 10: vx = -1; vy = 0; break;
        case 64 + 11: vx = 0; vy = -1; break;
        case 64 + 12: vx = +1; vy = 0; break;
        case 32: launchBall(); // mySound.play();  // launch ball 

      }
    }

    function onMouseDown(event) {
      event.preventDefault();
      mouse.x = (event.offsetX / window.innerWidth) * 2 - 1;  //clientX is bad
      mouse.y = - (event.offsetY / window.innerHeight) * 2 + 1; //offsetX is exptal
      raycaster.setFromCamera(mouse, camera);
      const intersections = raycaster.intersectObjects(selectables, true);
      if (intersections.length > 0) {
        const object = intersections[0].object; // topmost object under click
        object.material.emissive.set(0x666633 - object.material.emissive.getHex());  //.emissive.set
        object.position.z = -1 - object.position.z;
      }
      renderer.render(scene, camera);
    }
    // function onClick(event) {

  </script>

</body>

</html>