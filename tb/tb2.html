<!DOCTYPE html>
<html>
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="icon" href="favicon.ico" type="image/x-icon">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <style>
    @font-face {
      font-family:'gameFont';src:url('Retro Gaming.ttf') format('truetype');
      font-weight:normal;font-style:normal;
    }
    :root {--btnsize:12vmin;}
    html,body { 
      background-color:#333; padding:0; margin:0; width:100vh; height:200vh; font-family:'gameFont',sans-serif;
    }
    @keyframes gradientAnimation { 
      0%  {background-position:10% 0%  ;}
      50% {background-position:91% 100%;}
      100%{background-position:10% 0%  ;}
    }
    @keyframes flashingAnimation { 
      50% {background-color: #993; box-shadow:0px 0px 5px 5px #993;}
    }
    #splashScreen {
      position:fixed;left:0;bottom:0;
      width: 100%; height:100%; text-align: center; color:white;
      border:1px solid black;
      background: linear-gradient(130deg, #262626, #ff7e00, #fff200);
      background-size: 200% 200%;
      animation: gradientAnimation 4s ease infinite;
    }
    #viewarea {position:fixed; z-index:1; display:none; bottom:0; left:0;}
    #canvas {position:fixed; z-index:1; display:none; top:0; left:0;}
    #helpDivContainer { margin: 32px; padding: 32px;}
    #helpDiv {
      display: none;
      z-index:4;position:fixed;  right: 0; bottom:0; height:fit-content; width:80%; 
      padding: 1rem 2rem 1rem 6rem; 
      box-shadow: 0px 4 px 8px 0px #333, 0px 8px 16px 8px #000; background-color:#666; border:double 4px black; border-radius: 20px; 
      color:white; font-family:'gameFont',sans-serif; font-size: 1.5rem;
      background-image:url('peach.gif');background-size:3rem;background-repeat:no-repeat;background-position:1rem;
    }
    #helpDiv a { color: cyan; }
    #helpDiv a:visited { color: pink; }    
    #helpDiv h2 {
      background-image:url('happy1.webp');background-size:contain;background-repeat: no-repeat;background-position:0px;
      padding:0 0 0 48px; color:#fff;
    }
    #title {position:fixed; z-index:2; top:0;  
      display:none;
      width:fit-content;
      margin:6px 0px 0px 0px;text-align:center; font-size:3vmin; color:white; white-space:pre;
      border: 6px outset #974; background-color:#530;
      box-shadow: 0px 0px 1px 1px black, 0px 0px 8px 8px white;
    }
    #controls {position:fixed; z-index:3; bottom:0; left:0; width:100%; display:none;}
    button {cursor:pointer;
            float:left;margin:0;padding:0;text-align:center; border-radius:8px; font-family:'gameFont',sans-serif;font-size: 4vmin;
            background-color:#666; color:white;
            background-repeat: no-repeat;}
    button:disabled {opacity:25%;}
    .btn1 { width:var(--btnsize); height:var(--btnsize); background-size:cover; 
            text-shadow: 2px 2px 3px black;
          } /* square button */
    .btn2 { width:var(--btnsize); height:var(--btnsize);font-size: 2.2vmin;}
    .separator { height:16px; clear:left; }
    .indepth {font-size:1.3rem;color:#EEE;}
  </style>
</head>
<body id="body">
  <div id="splashScreen">
    <div style="text-align: center; vertical-align:center; margin:1rem 0rem; font-size:5rem;"> TOAD BURN </div>
    <div style="text-align: center; margin:2rem 0rem; font-size:2rem;"> By Yen Lee Loh and Isaac Hutchison </div>
    <div id="statusBar" style="text-align: center; font-size:1.5rem; white-space:pre;">Click or press any key to start!</div>
  </div>
  <div id="preloadContainer" style="display:none;">
<img id="imgQuestion" src="question.webp"></img>
<img id="imgMarioE" src="marioE2.gif"></img>
<img id="imgMarioE2" src="marioE3.webp"></img>
<img id="imgMarioE3" src="marioE1.gif"></img>
<img id="imgMarioW" src="marioW2.gif"></img>
<img id="imgMarioW2" src="marioW3.gif"></img>
<img id="imgMarioW3" src="marioW1.gif"></img>
<img id="imgMarioS" src="marioS1.webp"></img>
<img id="imgMarioS2" src="marioS2.webp"></img>
<img id="imgMarioS4" src="marioS4.webp"></img>
<img id="imgMarioN" src="marioN1.webp"></img>
<img id="imgMarioN2" src="marioN2.webp"></img>
<img id="imgMarioN4" src="marioN4.webp"></img>
<img id="imgMarioDead" src="marioDead.gif"></img>
<img id="imgAsh1" src="ash1.webp"></img>
<img id="imgAsh2" src="ash2.webp"></img>
<img id="imgPeach1" src="peach1.webp"></img>
<img id="imgPeach2" src="peach2.webp"></img>
<img id="imgBowser" src="bowser.webp"></img>
<img id="imgGrass" src="grass.webp"></img>
<img id="imgDirt" src="dirt.webp"></img>
<img id="imgWater" src="water.webp"></img>
<img id="imgWater2" src="water2.webp"></img>
<img id="imgLava" src="lava.webp"></img>
<img id="imgLava2" src="lava2.webp"></img>
<img id="imgCrying1" src="cry1.webp"></img>
<img id="imgCrying2" src="cry2.webp"></img>
<img id="imgHappy1" src="happy1.webp"></img>
<img id="imgHappy2" src="happy2.webp"></img>
<img id="imgStarOn" src="staron.webp"></img>
<img id="imgStarOff" src="staroff.webp"></img>
<img id="imgSourceOff" src="sourceoff.webp"></img>
<img id="imgSourceOn" src="sourceon.webp"></img>
<img id="imgBrick" src="brick.webp"></img>
<audio id="audioBuzz"><source src="buzz.mp3"></audio>
<audio id="audioWin1"><source src="win1.mp3"></audio>
<audio id="audioWin2"><source src="win2.mp3"></audio>
<audio id="audioCoin"><source src="coin.mp3"></audio>
<audio id="audioTock"><source src="tock.mp3"></audio>
<audio id="audioLose"><source src="lose.mp3"></audio>
<audio id="audioHoo"><source src="hoo.mp3"></audio>
<audio id="audioOw"><source src="ow.mp3"></audio>
  </div>
  
  <div id="helpDivContainer">
    <div id="helpDiv"></div>
  </div>
  <div id="title"></div> 
  <canvas id="canvas">Your browser does not support the HTML5 canvas tag.</canvas>
  
  <div id="controls" style="position:fixed; bottom:0; left:0; width:100%;">
    <div style="position: absolute; left:0;bottom:0; width:calc(3*var(--btnsize));" id="joyContainer">
      <div id="joyring" style="
      z-index:2; position:absolute; left:0; bottom:0; width:130px; height:130px; 
      background-image:url('joystick.webp'); background-position:center; background-size:130px; background-repeat: no-repeat;">
      </div>
      <div id="joystick" style="
      display:none;
      z-index:3; position:absolute; left:0; bottom:0; width:130px; height:130px; 
      background-image:url('joystick.webp'); background-position:center; background-size:90px; background-repeat: no-repeat;
      color:white; text-align:center; vertical-align:middle;
      transform:translate(0,0);">
      <div style="height: 8px;"></div><br>E<br>S &nbsp; &nbsp;  F<br> D
      </div>
    </div>
    <div style="display:flex; vertical-align:bottom; float:right; margin:0ex 0ex 0ex 0ex;">
      <div>
      <div style="height: 3vmin;"></div>
      <input type="range" min="0" max="200" value="50" class="slider" id="sliderSpeed">
      <div id="divSpeed" style="color:white; font-size: 2vmin; text-align:center;">DELAY</div>
      </div>
      <button id="btnCheat" class="btn2" title="Key: Shift-C"> CHEAT</button>
      <button id="btnPrev"  class="btn2" title="Key: [">       PREV </button>
      <button id="btnReset" class="btn2" title="Key: Shift-R"> RESET </button>
      <button id="btnNext"  class="btn2" title="Key: [">       NEXT  </button>
    </div>
    <div style="float:right; width:calc(5*var(--btnsize));" id="actionButtons">
      <button id="btnLava"  class="btn1" style="background-image:url(lava.webp);" disabled="disabled"> H </button>
      <button id="btnWater" class="btn1" style="background-image:url(water.webp);" disabled="disabled"> J </button>
      <button id="btnCross" class="btn1" style="background-image:url(crossing.webp);" disabled="disabled"> K </button>
      <button id="btnToad"  class="btn1" style="background-image:url(happy1.webp); color:#FFF;" disabled="disabled"> L </button>
      <button id="btnGrass" class="btn1" style="background-image:url(grass.webp);" disabled="disabled"> ; </button>
    </div>
  </div>




  <script type="module">
    import {loadString,Sound,Animation,isKeyDown} from "./utils.js";

    //=================================================
    // GAMEPLAY VARIABLES AND FUNCTIONS
    //=================================================
    const ON=1,FRESH=2,CONDUCTING=4,SOURCE=8,GATE=16
    const WALL=1,UNWALKABLE=2,LAMP=4,PEACH=8,BOWSER=16,QUESTION=32
    const PLAYING=0,WIN=1,PEACH_DIED=-1,MARIO_DIED=-2
    const DIRS=[[1,0],[-1,0],[0,1],[0,-1]]
    
    let X,Y // level size
    let xCursor,yCursor  // cursor (Mario) position
    let ground,groundNew,subway,subwayNew,extras // level map
    let lastDirWalked,stalled=false
    let helpText=''
    let winlose=PLAYING 
    let preconverge=100,cheating=0

    const starSize =2.0 // can make this a TOADML flag

    let joyForce=0

    function setPos(xnew,ynew) {xCursor=xnew;yCursor=ynew;xCurPrev=xCursor;yCurPrev=yCursor}
    function tryWalk(dir) {
      if (marioOrientation!=dir) {marioOrientation=dir; stalled=true; setTimeout(()=>stalled=false,50); return true} // Mario changes direction
      if (stalled) return false // already got stuck going in that direction
      stalled=false; 
      const dx=DIRS[dir][0],dy=DIRS[dir][1]
      let xnew=xCursor+dx,ynew=yCursor+dy
      //======== Check for various cases including collisions with objects
      if (xMario!=xCursor || yMario!=yCursor) return false // Previous walk in progress; do nothing
      //======== Check for transition to next/prev level
      if (xnew<=-1 && level>0) {setLevel(level-1); return}
      if (xnew>=X) {setLevel(level+1); return}
      if (xnew<0||xnew>=X||ynew<0||ynew>=Y) {soundBuzz.play(); stalled=true; return false} // Illegal move
      const G=ground[xnew+X*ynew],H=extras[xnew+X*ynew]
      if (H & WALL) {soundBuzz.play(); stalled=true; return false} // Can't walk into wall
      if (H & QUESTION) { // Mario bumps a Question block
        audioCoin.play(); openHelp(); helpDiv.focus(); return false
      }
      if (H & UNWALKABLE) {soundBuzz.play(); stalled=true; return false} // Can't walk into wall
      if (G & SOURCE) {                // Mario bumps a P Switch
        audioTock.play(); ground[xnew+X*ynew] ^= ON  // Toggle the ON/OFF state
        stalled=true; return false
      }
      if (G & GATE) { // Mario bumps a toad
        if (G & ON) {soundOw.play()} else soundHoo.play(); // Play appropriate sound
        ground[xnew+X*ynew] ^= ON; stalled=true; return false            // Toggle the toad state
      }
      //======== No obstacles; start walking!
      soundTock.play(); setTimeout(()=>soundTock.play(),130); xCursor=xnew; yCursor=ynew; tWalk=Date.now(); return true
    }
    function faceW() {marioOrientation=1}
    function faceE() {marioOrientation=0}
    function faceN() {marioOrientation=3}
    function faceS() {marioOrientation=2}
    function walkW() {tryWalk(1)}
    function walkE() {tryWalk(0)}
    function walkN() {tryWalk(3)}
    function walkS() {tryWalk(2)}
    // function goSlow()  {timeStepInMilliseconds=100}
    // function goFast()  {timeStepInMilliseconds=0}
    function placeLava()  {let x=xCursor+DIRS[marioOrientation][0],y=yCursor+DIRS[marioOrientation][1];ground[x+X*y]=FRESH|ON|CONDUCTING; audioCoin.play()}
    function placeWater() {let x=xCursor+DIRS[marioOrientation][0],y=yCursor+DIRS[marioOrientation][1];ground[x+X*y]=CONDUCTING; audioCoin.play()}
    function placeGrass() {let x=xCursor+DIRS[marioOrientation][0],y=yCursor+DIRS[marioOrientation][1];ground[x+X*y]=0;    audioCoin.play()}
    function placeToad()  {let x=xCursor+DIRS[marioOrientation][0],y=yCursor+DIRS[marioOrientation][1];ground[x+X*y]=GATE; audioCoin.play()}
    function placeSubway(){ // actually TOGGLE SUBWAY ON/OFF
      let x=xCursor+DIRS[marioOrientation][0],y=yCursor+DIRS[marioOrientation][1];
      if(subway[x+X*y]) {
        subway[x+X*y]=0
        if (!ground[x+X*y]) ground[x+X*y]=CONDUCTING
      }
      else subway[x+X*y]=3
    }
    function toggleCheating() {
      if (cheating) {
        cheating = 0
      }
      else {
        cheating = 1
      }
      btnLava.disabled = !cheating
      btnWater.disabled = !cheating
      btnToad.disabled = !cheating
      btnCross.disabled = !cheating
      btnGrass.disabled = !cheating
    }


    function extract(tag, source) {
      const regex = new RegExp('\\s+<' + tag + '>(.*?)<\/' + tag + '>', 'gs')
      const match = regex.exec(source)
      if (match) return [match[1], source.replace(regex,'')]
      else return ["", source]
    }

    function setLevel(newLevel) {
      stalled=true           // Don't ever start a new level while walking
      if (newLevel<0) return // if new level number is illegal, don't load it
      if (newLevel>=levelMaps.length) newLevel=levelMaps.length-1
      level = newLevel
      loadLevel(levelMaps[level])
      setScaling()
      btnPrev.disabled = (level==0)             // if current level is 0, disable "Previous Level" button
      btnNext.disabled = (level==levelMaps.length-1) // if we are on last level, disable "Next Level" button
      btnNext.style.animation = ""
      btnReset.style.animation = ""
      localStorage.setItem("storedLevel", level)
      document.activeElement.blur()  // remove focus from whatever button was pressed
    }
    function prevLevel() {setLevel(level-1)} 
    function nextLevel() {setLevel(level+1)} 
    function resetLevel() {setLevel(level)}
    function loadLevel(levelMap) {
      // console.log(level)
      // console.log(levelMap)


      preconverge=100; cheating=0; helpText='Level '+level  // defaults
      {
        const [content,remainder]=extract('timestep', levelMap); levelMap=remainder
        if(content) {
          timeStepInMilliseconds = Number(content)
          sliderSpeed.value = timeStepInMilliseconds
        }
      }
      {const [content,remainder]=extract('name', levelMap); levelMap=remainder;levelName=content}
      {const [content,remainder]=extract('preconverge', levelMap); levelMap=remainder; if(content) preconverge=Number(content)}
      {const [content,remainder]=extract('cheat', levelMap); levelMap=remainder; if(content) cheating=Number(content)}
      {const [content,remainder]=extract('help', levelMap); levelMap=remainder; if(content) helpText=content}
      if (levelName) {title.innerHTML=levelName; title.style.display='block'}
      else           {title.style.display='none'}
      btnLava.disabled = !cheating
      btnWater.disabled = !cheating
      btnToad.disabled = !cheating
      btnCross.disabled = !cheating
      btnGrass.disabled = !cheating
      let rows = /<levelmap>\s*?[\r\n](.*?)<\/levelmap>/gs . exec(levelMap)
      try { rows = rows[1] } catch (e) { rows = '####M####'}
      rows = rows.split(/[\r\n]/).filter(i=>i)
      //-------- DETERMINE MAP SIZE AND ALLOCATE ARRAYS
      X = Math.max(...rows.map(s=>s.length)) // length of longest line
      Y = rows.length 
      ground   = new Int8Array(X*Y)
      groundNew= new Int8Array(X*Y)
      subway   = new Int8Array(X*Y)
      subwayNew= new Int8Array(X*Y)
      extras   = new Int8Array(X*Y)
      //-------- POPULATE ARRAYS
      for (let y=0; y<Y; ++y) {
        for (let x=0; x<rows[y].length && x<X; ++x) {
          let g
          switch (rows[y][x]) {
            case '.': g=0; break   // grass
            case ' ': g=0; extras[x+X*y]=UNWALKABLE; break   // poison
            case 'W': g=0; extras[x+X*y]=WALL; break   // void (forbidden)
            case '#': g=CONDUCTING; break           // dirt
            case 'H': g=CONDUCTING|ON|FRESH; break
            case 's': g=SOURCE|FRESH;    break 
            case 'S': g=SOURCE|FRESH|ON; break 
            case 'n': g=GATE;    break // NOR gate, initially off?
            case 'N': g=GATE|ON; break // NOR gate, initially off?
            case '+': g=CONDUCTING; subway[x+X*y]=CONDUCTING; break // crossing
            case 'L': g=CONDUCTING; extras[x+X*y]=LAMP; break // Lamp
            case 'P': g=CONDUCTING; extras[x+X*y]=PEACH; break // Peach starts unburned
            case 'B': g=CONDUCTING; extras[x+X*y]=BOWSER; break // Bowser starts unburned
            case '?': g=0; extras[x+X*y]=QUESTION; break // Question block
            default: g=0
          }
          ground[x+X*y]=g
        }
      }
      //-------- GAMEPLAY: PRE-CONVERGE TO STEADY STATE PREVENT PREMATURE WIN
      Sound.masterVolume = 0 // don't play annoying toad sounds while preconverging
      for (let iter=0; iter<preconverge; ++iter) evolve()
      Sound.masterVolume = 1
       //-------- GAMEPLAY: LOAD PEACHES AND BOWSERS AGAIN (IN CASE THEY GOT BURNED DURING PRE-CONVERGENCE)
      for (let y=0; y<rows.length; ++y) {
        for (let x=0; x<rows[y].length && x<X; ++x) {
          switch (rows[y][x]) {
            case 'P': ground[x+X*y]=CONDUCTING; extras[x+X*y]=PEACH; break // Peach starts unburned
            case 'B': ground[x+X*y]=CONDUCTING; extras[x+X*y]=BOWSER; break // Bowser starts unburned            
          }
        }
      }
      //-------- GAMEPLAY: IDENTIFY START POSITION
      for (let y=0; y<Y; ++y) for (let x=0; x<X; ++x) if (rows[y][x]=='M') setPos(x,y)
      xShaking=0; yShaking=0; tcur=0; winlose=PLAYING
    }
    //===============================================
    // evolve(): EVOLVE CELLULAR AUTOMATON
    //===============================================
    function evolve() {

      //======== Calculate groundNew[...] 
      for (let y=1; y<Y-1; ++y) for (let x=1; x<X-1; ++x) {
        const G=ground[x+X*y]
        groundNew[x+X*y]=G 
        if (G&SOURCE) {groundNew[x+X*y]=G;         continue} // Source persists unchanged 
        if (G&FRESH)  {groundNew[x+X*y]=G & ~FRESH;continue} // Fresh cell goes stale
        //======== We need to consider neighbors
        let E=ground[(x+1)+X*y]
        let W=ground[(x-1)+X*y]
        
        let N,S;
        if (subway[x+X*y]) {N=0; S=0} // If subway exists, then ground has no N and S neighbors
        else {
          // If North neighbor has a subway, use the subway value; otherwise use ground value
          N=subway[x+X*(y-1)]; if(N==0) N=ground[x+X*(y-1)]
          S=subway[x+X*(y+1)]; if(S==0) S=ground[x+X*(y+1)]
        }
        // N=ground[x+X*(y-1)]
        // S=ground[x+X*(y+1)]        
        let EE=E&(CONDUCTING|SOURCE)
        let WW=W&(CONDUCTING|SOURCE|GATE)
        let NN=N&(CONDUCTING|SOURCE)
        let SS=S&(CONDUCTING|SOURCE)
        //======== If cell is a NOR gate, do NOR logic
        if (G&GATE) {
          if      ( !WW && !NN && !SS ) continue                              // gate has no inputs
          else if ( !(W&ON) && !(N&ON) && !(S&ON)) groundNew[x+X*y] = GATE|ON // all inputs are OFF
          else if (  WW&&(W&ON)  || NN&&(N&ON)  || SS&&(S&ON) ) groundNew[x+X*y] = GATE&~ON

          if      (G&ON && !(groundNew[x+X*y]&ON)) soundOw.play();    // gate switched OFF
          else if (!(G&ON) && (groundNew[x+X*y]&ON)) soundHoo.play(); // gate switched ON
          continue
        }
        //======== Cell is a normal conducting cell.  Check if any neighbors are FRESH, and if so, are they ON or OFF
        if (G&CONDUCTING) {
          let flag=false,env=0 // env is the sum of +1's or -1's for each neighbor
          // if (W & GATE ) {flag=true; env+=(W&ON)?1:-1}
          if (E & FRESH) {flag=true; env+=(E&ON)?1:-1}
          if (W & FRESH) {flag=true; env+=(W&ON)?1:-1}
          if (N & FRESH) {flag=true; env+=(N&ON)?1:-1}
          if (S & FRESH) {flag=true; env+=(S&ON)?1:-1}
          if (flag) { // Check whether we end up flipping state
            if      (!(G&ON) && env>=0) groundNew[x+X*y] = G | ON | FRESH
            else if ((G&ON) && env<=0) groundNew[x+X*y] = (G & (~ON)) | FRESH  
          }

          if (W & GATE) groundNew[x+X*y] = CONDUCTING | (W&ON) | FRESH // if fed by a gate, MUST be fresh - overrides prev.
        
          //======== Special handling: PEACH and BOWSER are absorbers (cannot be FRESH)
          // Also, if PEACH or BOWSER are already set on fire, they cannot be extinguished
          let H=extras[x+X*y]
          if (H & PEACH || H & BOWSER) {
            groundNew[x+X*y] &= ~FRESH
            if (ground[x+X*y]&ON)  groundNew[x+X*y] |= ON
          }
          continue
        }
      }

      //======== Calculate subwayNew[...] based on NORTH and SOUTH neighbors only
      for (let y=1; y<Y-1; ++y) for (let x=1; x<X-1; ++x) {
        const H = subway[x+X*y]
        subwayNew[x+X*y] = H // default: same

        if (!H) continue  // not a crossing
        if (H&FRESH)  {subwayNew[x+X*y]=H & ~FRESH;continue} // Fresh cell goes stale

        const N=ground[x+X*(y-1)]
        const S=ground[x+X*(y+1)]
        let flag=false,env=0 // env is the sum of +1's or -1's for each neighbor  
        if (N & FRESH) {flag=true; env+=(N&ON)?1:-1}
        if (S & FRESH) {flag=true; env+=(S&ON)?1:-1}
        if (flag) { // Check whether we end up flipping state
          if      (!(H&ON) && env>=0) subwayNew[x+X*y] = H | ON | FRESH
          else if ( (H&ON) && env<=0) subwayNew[x+X*y] = (H & (~ON)) | FRESH  
        }
      }
      
      //======== Do synchronous updates on ground and subway
      for (let y=1; y<Y-1; ++y) for (let x=1; x<X-1; ++x) ground[x+X*y]=groundNew[x+X*y]
      for (let y=1; y<Y-1; ++y) for (let x=1; x<X-1; ++x) subway[x+X*y]=subwayNew[x+X*y]
    }



    //=======================================================
    // UTILITIES
    //=======================================================
    const clamp=(x,a,b) => Math.min(Math.max(x,a),b)
    // function log(s) { statusBar.innerText += ' '+s+'\n' }
    //=================================================
    // GRAPHICS (VARIABLES AND FUNCTIONS)
    //=================================================
    const ctx=canvas.getContext('2d')
    let winWid,winHei,cellsize
    let marioOrientation=2 // start game facing South
    let xCurPrev,yCurPrev  // variables associated with Mario's
    let xMario,yMario,nWalk=0,tWalk=0 // appearance (but not gameplay)
    let tcur=0
    let timeOfLastFrame=0
    let timeStepInMilliseconds = 1000/60.  //300.
    let level=0,levelName // current level
    let xShaking=0,yShaking=0

    function setScaling() {
      winWid=visualViewport.width||window.innerWidth||document.documentElement.clientWidth||document.body.clientWidth
      winHei=visualViewport.height||window.innerHeight||document.documentElement.clientHeight||document.body.clientHeight
      let availWidth =clamp(winWid, 300, 3000) // set canvas width according to window width; warning: btnSize=48
      let availHeight=clamp(winHei*(1-.08), 300, 3000) // may reduce this
      cellsize=Math.min(Math.floor(availWidth/X),Math.floor((availHeight)/Y)) // for graphics
      canvas.width=X*cellsize
      canvas.height=Y*cellsize
      canvas.style.left = Math.floor((winWid-canvas.width)/2) + "px"
      title.style.left  = Math.floor((winWid-title.offsetWidth)/2) + "px"      
    }
    function render() {
      tcur += 1
      const a=cellsize // convenience ALIAS
      //======== DRAW BACKGROUND AND GAME AREA
      ctx.clearRect(0, 0, canvas.width, canvas.height)
      ctx.fillStyle='#000';   ctx.fillRect(0,0, X*a, Y*a)
      //======== DRAW TERRAIN
      ctx.lineWidth=2 //; ctx.font = '10px Arial'
      for (let y=0; y<Y; ++y) for (let x=0; x<X; ++x) {
        const g=ground[x+X*y]
        const frm=(tcur+4*x+13*y)/17

        if (g==0)          {ctx.drawImage(imgGrass, x*a,y*a,a,a) }
        else if (g & CONDUCTING) {
          if (g & ON)  animLava.draw(x*a, y*a, a, a, frm) // conducting, on
          else         animWater.draw(x*a, y*a, a, a, frm)// conducting, off
        }
        else if (g & SOURCE) {
          if (g & ON) {animLava.draw(x*a,y*a,a,a, frm); ctx.drawImage(imgSourceOn, x*a,y*a,a,a)} // P Switch on
          else        {animWater.draw(x*a,y*a,a,a,frm); ctx.drawImage(imgSourceOff, x*a, y*a, a, a)} // P Switch off
        }
        else if (g & GATE) {
          if (g & ON) { // gate is ON
            animWater.draw(x*a, y*a, a, a, frm)
            animHappy.draw(x*a,y*a,a,a, tcur/14)
          } else { // gate is OFF
            animWater.draw(x*a, y*a, a, a, frm)
            if (ground[(x-1)+X*y]&ON) ctx.drawImage(imgLava, 0,0,16,32, x*a,y*a,a/2,a)
            if (ground[x+X*(y-1)]&ON) ctx.drawImage(imgLava, 0,0,32,16, x*a,y*a,a,a/2)
            if (ground[x+X*(y+1)]&ON) ctx.drawImage(imgLava, 0,16,32,16, x*a,y*a+a/2,a,a/2)
            animCrying.draw(x*a,y*a,a,a, tcur/15)
          }
        }
        
        if (subway[x+X*y]) { // draw crossing as "bridge"
          ctx.fillStyle='#964B00' // brown wood bridge
          ctx.fillRect(x*a,y*a, a,4)
          ctx.fillRect(x*a,y*a+a-4, a,4)
        }
      }

      for (let y=0; y<Y; ++y) for (let x=0; x<X; ++x) {
        switch (extras[x+X*y]) {
          case UNWALKABLE: ctx.fillStyle='#000';ctx.fillRect(x*a, y*a, a, a); break // void
        }
      }

      //======== DRAW CERTAIN EXTRAS (WALLS)
      for (let y=0; y<Y; ++y) for (let x=0; x<X; ++x) {
        switch (extras[x+X*y]) { 
          case WALL: ctx.drawImage(imgBrick, x*a, y*a, a, a); break
        }
      }
      //======== DRAW CERTAIN EXTRAS (QUESTION BLOCKS, LAMPS, ETC.)
      let size,xcen,ycen,sx,sy
      for (let y=0; y<Y; ++y) for (let x=0; x<X; ++x) {
        const frm=(tcur+4*x+13*y)/20
        switch (extras[x+X*y]) {
          case WALL: break; // this was done in the earlier loop
          case QUESTION: ctx.drawImage(imgQuestion, x*a,y*a,a,a); break  
          case LAMP:
            xcen=(x+.5)*a; ycen=(y+.5)*a
            if (ground[x+X*y]&ON) {
              if ((Math.floor(tcur/10)%2)) {sx=1.05*starSize*a; sy=sx}
              else                         {sx=starSize*a; sy=sx}
              ctx.drawImage(imgStarOn, xcen-sx/2, ycen-sy/2, sx,sy)
              // should remake this into an Animation
            }
            else {
              sx=starSize*a; sy=sx
              ctx.drawImage(imgStarOff,  xcen-sx/2, ycen-sy/2, sx,sy)
            }
            break
          case PEACH:
            sy=a,sx=a/animPeach.aspect
            if (ground[x+X*y]&ON) {
              animLava.draw(x*a, y*a, a, a, frm)
              const xcen=(x+.5)*a + xShaking,ycen=(y+.5)*a + yShaking
              ctx.save(); // Save current canvas state
              ctx.translate(xcen,ycen); // Translate to the center of the image
              ctx.rotate(tcur*.1); // Rotate  by radians
              animPeach.draw(-sx/2, -sy/2, sx, sy, 0)
              ctx.restore(); // Restore the canvas to its original state
              if (tcur<100) {xShaking+=Math.cos(tcur*.6)*2; yShaking=Math.sin(tcur*.3)*10 }
              else {xShaking=0; yShaking += (tcur-20)*.03}
              if (tcur>150) {ctx.drawImage(imgDirt, x*a,y*a,a,a);animAsh.draw(x*a,y*a,a,a,tcur/10)}
            } else {
              const xcen=(x+.5)*a,ycen=(y+.5)*a
              animWater.draw(x*a, y*a, a, a, frm)   
              animPeach.draw(xcen-sx/2, ycen-sy/2, sx,sy, tcur/41)                 
            }
            break
          case BOWSER:
            if (ground[x+X*y]&ON) {
              animLava.draw(x*a, y*a, a, a, frm)
              size=a*1.1,xcen=(x+.5)*a+xShaking,ycen=(y+.5)*a+yShaking
              ctx.drawImage(imgBowser, xcen-size/2, ycen-size/2, size,size)
              if (tcur<100) {xShaking+=Math.cos(tcur*.6)*2; yShaking=Math.sin(tcur*.3)*10 }
              else {xShaking=0; yShaking+=(tcur-20)*.03}  
              if (tcur>150) {ctx.drawImage(imgDirt, x*a,y*a,a,a);animAsh.draw(x*a,y*a,a,a,tcur/10)}
            } else {
              size=a*1.1,xcen=(x+.5)*a,ycen=(y+.5)*a
              animWater.draw(x*a, y*a, a, a, frm)     
              ctx.drawImage(imgBowser, xcen-size/2, ycen-size/2, size,size)
            }
            break
        }
      }
      //======== DRAW MARIO
      if (winlose==MARIO_DIED) {
        // Mario is burned (dead)
        const x=xCursor,y=yCursor
        const xcen=(x+.5)*a+xShaking,ycen=(y+.5)*a+yShaking,sx=a,sy=a
        ctx.drawImage(imgMarioDead, xcen-sx/2, ycen-sy/2, sx,sy);

        if (tcur<100) {xShaking+=Math.cos(tcur*1.2)*2; yShaking=Math.sin(tcur*.7)*10 }
        else {xShaking=0; yShaking+=(tcur-20)*.03}      

      } else {
        const maxWalkSteps = 6
        if (xCurPrev!=xCursor||yCurPrev!=yCursor) nWalk = Math.floor(((Date.now() - tWalk))/17) // 17 ms per frame
        if (nWalk>=maxWalkSteps) {  xCurPrev=xCursor; yCurPrev=yCursor; nWalk=0} // go back to standing still
        xMario = xCurPrev + (xCursor-xCurPrev)*nWalk/maxWalkSteps
        yMario = yCurPrev + (yCursor-yCurPrev)*nWalk/maxWalkSteps
        
        //let asp=imgMarioE.height/imgMarioE.width;
        ctx.imageSmoothingEnabled = false
        const xcen=(xMario+.5)*a,ycen=(yMario+.5)*a,sx=a,sy=a //,sy=a,sx=sy/asp
        switch (marioOrientation) {
          case 0: animMarioE.draw(xcen-sx/2, ycen-sy/2, sx,sy, nWalk); break
          case 1: animMarioW.draw(xcen-sx/2, ycen-sy/2, sx,sy, nWalk); break
          case 2: animMarioS.draw(xcen-sx/2, ycen-sy/2, sx,sy, nWalk); break
          case 3: animMarioN.draw(xcen-sx/2, ycen-sy/2, sx,sy, nWalk); break
        }
      }
      //======== DEBUGGING
      // if (cheating) {
      //   for (let y=0; y<Y; ++y) for (let x=0; x<X; ++x) { 
      //     ctx.fillStyle='#fff'
      //     ctx.font = 'bold 20px sans-serif'
      //     ctx.fillText(ground[x+X*y],  (x+.5)*a, (y+.5)*a)
      //   }
      // }
    }
    
    function checkVictory() {
      if (cheating) return // can't lose in cheat mode
      if (winlose==PLAYING) {
        for (let y=0; y<Y; ++y) for (let x=0; x<X; ++x) {
          if (extras[x+X*y]==BOWSER && ground[x+X*y]&ON) {winlose=WIN; break}
          if (extras[x+X*y]==PEACH && ground[x+X*y]&ON) {winlose=PEACH_DIED; break}
        }
        if (ground[xCursor+X*yCursor]&ON) winlose=MARIO_DIED  // Mario is burning!
        if (extras[xCursor+X*yCursor]==BOWSER) winlose=MARIO_DIED  // Mario got eaten by Bowser

        if (winlose==WIN) {
          tcur=0; audioWin1.play(); setTimeout( ()=>audioWin2.play(), 1000);               
          setTimeout(()=>btnNext.style.animation = 'flashingAnimation 0.5s step-start infinite', 500)
        }
        else if (winlose==MARIO_DIED||winlose==PEACH_DIED) {
          tcur=0;audioLose.play(); 
          setTimeout(()=>btnReset.style.animation = 'flashingAnimation 0.5s step-start infinite', 500)
        }
      }  
    }
    function animate(timeCurrent) {
      requestAnimationFrame(animate)
      render() 
      checkVictory()
      
      if      (isKeyDown('s')||isKeyDown('S')) walkW()//if (isKeyDown('ArrowLeft')) walkW()
      else if (isKeyDown('f')||isKeyDown('F')) walkE()
      else if (isKeyDown('e')||isKeyDown('E')) walkN()
      else if (isKeyDown('d')||isKeyDown('D')) walkS()
      else { // process joystick ONLY if keyboard is not active
        joyForce = Math.hypot(joyX,joyY) 
        if (joyForce<5) { // weak force, do nothing
        }
        else if (joyForce>10) { //strong force, walk
          if (Math.abs(joyX)>Math.abs(joyY)) if (joyX>0) {walkE()} else walkW()
          else                         if (joyY>0) {walkS()} else walkN()
        }
        else { // medium force, change direction only
          if (Math.abs(joyX)>Math.abs(joyY)) if (joyX>0) {faceE()} else faceW()
          else                         if (joyY>0) {faceS()} else faceN()
        }
      }
  
      const elapsed = Date.now() - timeOfLastFrame
      if (elapsed <= timeStepInMilliseconds) return
      timeOfLastFrame = Date.now()
      evolve()
    }

    //=================================================
    // HELP
    //=================================================
    function closeHelp() {helpDiv.style.display="none"}
    function openHelp() {
      winWid=window.innerWidth||document.documentElement.clientWidth||document.body.clientWidth
      winHei=window.innerHeight||document.documentElement.clientHeight||document.body.clientHeight
      const wid=winWid - 64
      const hei=winHei - 64
      helpDiv.style.display = "block"
      helpDiv.innerHTML = helpText
      helpDiv.onclick = closeHelp
      helpDiv.focus()
      // let utterance = new SpeechSynthesisUtterance(convertHtmlToText(helpText))
      // utterance.pitch = 8.0
      // utterance.rate = 3.0
      // speechSynthesis.speak(utterance)
    }
    //=================================================
    // INTERACTIVITY
    //=================================================
    function keyDown(e) {
      if (helpDiv.style.display=="block") {helpDiv.style.display="none"; return}

      if (e.ctrlKey||e.altKey) return // don't trap browser shortcuts involving Ctrl or Alt
      let processed=true
      switch (e.key) {
        case '[': prevLevel(); break
        case ']': nextLevel(); break
        case 'h':case'H':if(cheating) placeLava(); break    // add hot burning
        case 'j':case'J':if(cheating) placeWater(); break    // add cold burning
        case 'k':case'K':if(cheating) placeSubway(); break // toggle crossing
        case 'l':case'L':if(cheating) placeToad(); break    // add NOR gate (Toad)
        case ';':case';':if(cheating) placeGrass(); break // erase current ground  //case 'Backspace': case 'Delete':                 
        case 'C': toggleCheating(); break
        case 'R': resetLevel(); break    // reset level
        default: processed=false
      }
      
      if (processed) {e.preventDefault(); e.stopPropagation(); }
    }
    function keyUp(e) {
      stalled=false
    }
    let joyAnchorX,joyAnchorY,joyX=0,joyY=0;
    function joyTouchStart(e) {
      e.preventDefault()
      // joyAnchorX=event.touches[0].pageX // not appropriate
      // joyAnchorY=event.touches[0].pageY
      const rect = joyring.getBoundingClientRect()
      joyAnchorX = (rect.left + rect.right)/2
      joyAnchorY = (rect.top + rect.bottom)/2
      
      // console.log([joyAnchorX,joyAnchorY])
      // console.log([event.touches[0].clientX,event.touches[0].clientY])

      joyX=clamp(event.touches[0].clientX-joyAnchorX,-30,30)
      joyY=clamp(event.touches[0].clientY-joyAnchorY,-30,30)
      joystick.style.transform=`translate(${joyX}px,${joyY}px)`
      joyForce = Math.hypot(joyX,joyY) // decide whether to walk ONE STEP
      if (joyForce<5) { // weak force, do nothing
      }
      else if (joyForce>10) { //strong force, walk
        if (Math.abs(joyX)>Math.abs(joyY)) if (joyX>0) {walkE()} else walkW()
        else                         if (joyY>0) {walkS()} else walkN()
      }
      else { // medium force, change direction only
        if (Math.abs(joyX)>Math.abs(joyY)) if (joyX>0) {faceE()} else faceW()
        else                         if (joyY>0) {faceS()} else faceN()
      }
    }
    function joyTouchMove(e) {
      e.preventDefault()
      joyX=clamp(event.touches[0].clientX-joyAnchorX,-30,30)
      joyY=clamp(event.touches[0].clientY-joyAnchorY,-30,30)
      joystick.style.transform=`translate(${joyX}px,${joyY}px)`
    }
    function joyTouchEnd(e) {
      joyX=0; joyY=0
      joystick.style.transform='translate(0,0)'
      stalled=false
    }
    function launchGame() {
      level = localStorage.getItem("storedLevel")
      if (level) {level=Number(level)} else level=0
      if (!level) level=0
      setLevel(level)
      tcur = 0
      setScaling()

      btnReset.addEventListener('click', resetLevel)
      btnPrev.addEventListener('click', prevLevel)
      btnNext.addEventListener('click', nextLevel)
      btnLava.addEventListener('click', placeLava)
      btnWater.addEventListener('click', placeWater)
      btnCross.addEventListener('click', placeSubway)
      btnGrass.addEventListener('click', placeGrass)
      btnToad.addEventListener('click', placeToad)
      btnCheat.addEventListener('click', toggleCheating)
      document.body.removeEventListener('keydown', launchGame, false)

      window.addEventListener('resize', setScaling)
      window.visualViewport.addEventListener('resize', setScaling)

      document.body.addEventListener('dblclick', e=>e.preventDefault())
      document.body.addEventListener('keydown', keyDown)
      document.body.addEventListener('keyup', keyUp)
      joystick.addEventListener('touchstart', joyTouchStart)
      joystick.addEventListener('touchmove',  joyTouchMove)
      joystick.addEventListener('touchend',  joyTouchEnd)
      splashScreen.style.display = 'none' // Hide splash screen
      joystick.style.display = 'block' // Show
      canvas.style.display = 'block' // Show
      controls.style.display = 'block'
      sliderSpeed.oninput=()=>{
        timeStepInMilliseconds=Number(sliderSpeed.value);
        divSpeed.innerText='DELAY '+timeStepInMilliseconds
      }
      requestAnimationFrame(animate)
    }

    //===============================================
    // MAIN MODULE CODE
    //===============================================
    Animation.ctx = ctx
    let animMarioE= new Animation([imgMarioE,imgMarioE2,imgMarioE3])
    let animMarioW= new Animation([imgMarioW,imgMarioW2,imgMarioW3])
    let animMarioN= new Animation([imgMarioN,imgMarioN2,imgMarioN,imgMarioN4])
    let animMarioS= new Animation([imgMarioS,imgMarioS2,imgMarioS,imgMarioS4])
    let animPeach = new Animation([imgPeach1,imgPeach2])
    let animLava  = new Animation([imgLava,imgLava2])
    let animWater = new Animation([imgWater,imgWater2])
    let animCrying= new Animation([imgCrying1,imgCrying2])
    let animHappy = new Animation([imgHappy1,imgHappy2])
    let animAsh   = new Animation([imgAsh1,imgAsh2])
    let soundTock = new Sound('tock.mp3'); soundTock.vol = .1
    let soundBuzz = new Sound('buzz.mp3')
    let soundWin1 = new Sound('win1.mp3')
    let soundWin2 = new Sound('win2.mp3')
    let soundHoo = new Sound('hoo.mp3'); soundHoo.vol = .03
    let soundOw = new Sound('ow.mp3'); soundOw.vol = .03
    let levelMaps = await loadString('maps.txt') // clear browser cache if this file is edited
    levelMaps = [...levelMaps.matchAll(  /<levelmap>.*?<\/levelmap>/gs )].map(i=>i[0])
    
    splashScreen.addEventListener('click', launchGame)
    document.body.addEventListener('keydown', launchGame, false)
  </script>
</body>
</html> 