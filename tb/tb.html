<!DOCTYPE html>
<html>
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="icon" href="favicon.ico" type="image/x-icon">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <style>
    @font-face {
      font-family:'gameFont';src:url('Retro Gaming.ttf') format('truetype');
      font-weight:normal;font-style:normal;
    }
    :root {--btnsize:10vmin;}
    html,body { 
      background-color:#333; padding:0; margin:0; width:100vh; height:200vh; font-family:'gameFont',sans-serif;
    }
    @keyframes gradientAnimation { 
      0%  {background-position:10% 0%  ;}
      50% {background-position:91% 100%;}
      100%{background-position:10% 0%  ;}
    }
    @keyframes flashingAnimation { 
      50% {background-color: #993; box-shadow:0px 0px 5px 5px #993;}
    }
    #splashScreen {
      position:fixed;left:0;bottom:0;
      width: 100%; height:100%; text-align: center; color:white;
      border:1px solid black;
      background: linear-gradient(130deg, #262626, #ff7e00, #fff200);
      background-size: 200% 200%;
      animation: gradientAnimation 4s ease infinite;
    }
    #canvas {position:fixed; z-index:1; display:none; top:0; left:0;}
    #helpDivContainer { margin: 32px; padding: 32px;}
    #helpDiv {
      display: none;
      z-index:4;position:fixed;  right: 0; bottom:0; height:fit-content; min-height:3rem; width:80%; 
      padding: 1rem 2rem 1rem 6rem; 
      box-shadow: 0px 4 px 8px 0px #333, 0px 8px 16px 8px #000; background-color:#666; border:double 4px black; border-radius: 20px; 
      color:white; font-family:'gameFont',sans-serif; font-size: 1.5rem;
      background-image:url('peach1E.webp');background-size:2.5rem;background-repeat:no-repeat;background-position:1rem;
    }
    #helpDiv a { color: cyan; }
    #helpDiv a:visited { color: pink; }    
    #title {position:fixed; z-index:2; top:0;  
      display:none;
      width:fit-content;
      margin:6px 0px 0px 0px;text-align:center; font-size:3vmin; color:white; white-space:pre;
      border: 6px outset #974; background-color:#530;
      box-shadow: 0px 0px 1px 1px black, 0px 0px 8px 8px white;
    }
    #controls {position:fixed; z-index:3; bottom:0; left:0; width:100%; display:none;}
    img {image-rendering: pixelated;}
    button {cursor:pointer;
            float:left;margin:0;padding:0;text-align:center; border-radius:8px; font-family:'gameFont',sans-serif;font-size: 4vmin;
            background-color:#666; color:white;
            background-repeat: no-repeat;
            image-rendering: pixelated;
          }
    button:disabled {visibility:hidden;}
    .btn1 {width:var(--btnsize); height:var(--btnsize); background-size:cover; text-shadow: 2px 2px 3px black;}
    .btn1s{width:var(--btnsize); height:var(--btnsize); background-size:cover; text-shadow: 2px 2px 3px black; border:solid 5px yellow;}
    .btn2 {width:5rem; height:auto;font-size: 2.2vmin;}
    .indepth {font-size:1.3rem;color:#EEE;}
  </style>
</head>
<body id="body">
  <div id="splashScreen">
    <div style="text-align: center; vertical-align:center; margin:1rem 0rem; font-size:5rem;"> TOAD BURN </div>
    <div style="text-align: center; margin:2rem 0rem; font-size:2rem;"> By Yen Lee Loh and Isaac Hutchison </div>
    <div id="statusBar" style="text-align: center; font-size:1.5rem; white-space:pre;">Click or press any key to start!</div>
  </div>
  <div id="preloadContainer" style="display:none;">
<img id="imgQuestion" src="question.webp"></img>
<img id="imgMarioE" src="marioE2.webp"></img>
<img id="imgMarioE2" src="marioE3.webp"></img>
<img id="imgMarioE3" src="marioE1.webp"></img>
<img id="imgMarioW" src="marioW2.webp"></img>
<img id="imgMarioW2" src="marioW3.webp"></img>
<img id="imgMarioW3" src="marioW1.webp"></img>
<img id="imgMarioS" src="marioS1.webp"></img>
<img id="imgMarioS2" src="marioS2.webp"></img>
<img id="imgMarioS4" src="marioS4.webp"></img>
<img id="imgMarioN" src="marioN1.webp"></img>
<img id="imgMarioN2" src="marioN2.webp"></img>
<img id="imgMarioN4" src="marioN4.webp"></img>
<img id="imgMarioDead" src="marioDead.webp"></img>
<img id="imgAsh1" src="ash1.webp"></img>
<img id="imgAsh2" src="ash2.webp"></img>
<img id="imgPeach1" src="peach1.webp"></img>
<img id="imgPeach2" src="peach2.webp"></img>
<img id="imgBowser1234" src="bowser1234.webp"></img>
<img id="imgGrass" src="grass.webp"></img>
<img id="imgDirt" src="dirt.webp"></img>
<img id="imgWater" src="water1.webp"></img>
<img id="imgWater2" src="water2.webp"></img>
<img id="imgLava" src="lava1.webp"></img>
<img id="imgLava2" src="lava2.webp"></img>
<img id="imgCrying1" src="cry1.webp"></img>
<img id="imgCrying2" src="cry2.webp"></img>
<img id="imgHappy1" src="happy1.webp"></img>
<img id="imgHappy2" src="happy2.webp"></img>
<img id="imgStarOn" src="staron.webp"></img>
<img id="imgStarOff" src="staroff.webp"></img>
<img id="imgSourceOff" src="sourceoff.webp"></img>
<img id="imgSourceOn" src="sourceon.webp"></img>
<img id="imgPlateOff" src="plateoff.webp"></img>
<img id="imgPlateOn" src="plateon.webp"></img>
<img id="imgBrick" src="brick.webp"></img>
<img id="imgBridge" src="bridge.webp"></img>
<img id="imgMask" src="mask.webp"></img>

<audio id="audioBuzz"><source src="buzz.mp3"></audio>
<audio id="audioBowsFall"><source src="bowsfall.mp3"></audio>
<audio id="audioWin"><source src="win.mp3"></audio>
<audio id="audioCoin"><source src="coin.mp3"></audio>
<audio id="audioTock"><source src="tock.mp3"></audio>
<audio id="audioLose"><source src="lose.mp3"></audio>
<audio id="audioHoo"><source src="hoo.mp3"></audio>
<audio id="audioOw"><source src="ow.mp3"></audio>
  </div>
  
  <div id="helpDivContainer">
    <div id="helpDiv"></div>
  </div>
  <div id="title"></div> 
  <canvas id="canvas">Your browser does not support the HTML5 canvas tag.</canvas>
  
  <div id="controls" style="position:fixed; bottom:0; left:0; width:100%;">
    <div style="position: absolute; left:0;bottom:0; width:calc(3*var(--btnsize));" id="joyContainer">
      <div id="joyring" style="
      visibility:hidden;
      z-index:2; position:absolute; left:0; bottom:0; width:130px; height:130px; 
      background-image:url('joystick.webp'); background-position:center; background-size:130px; background-repeat: no-repeat;">
      </div>
      <div id="joystick" style="
      display:none;
      z-index:3; position:absolute; left:0; bottom:0; width:150px; height:150px; 
      background-image:url('dpad.webp'); background-position:center; background-size:130px; background-repeat: no-repeat;
      color:white; text-align:center; vertical-align:middle;">
      </div>
    </div>
    <div style="display:flex; vertical-align:bottom; float:right; margin:0ex 0ex 0ex 0ex;">
      <div>
      <div style="height: 3vmin;"></div>
      <input type="range" min="0" max="200" value="50" class="slider" id="sliderSpeed">
      <div id="divSpeed" style="color:white; font-size: 2vmin; text-align:center;">DELAY</div>
      </div>
      <button id="btnCheat" class="btn2" title="Key: Shift-C"> CHEAT</button>
      <button id="btnPrev"  class="btn2" title="Key: [">       PREV </button>
      <button id="btnReset" class="btn2" title="Key: Shift-R"> RESET </button>
      <button id="btnNext"  class="btn2" title="Key: [">       NEXT  </button>
    </div>
  </div>
  <div style="position:fixed; right:0; top:0; visibility:hidden; z-index:5; width:calc(2*var(--btnsize));
      border:solid 5px black; background-color: black;" id="divPalette">
    <button id="btnWall"  class="btn1" style="background-image:url(brick.webp);"></button>
    <button id="btnGrass" class="btn1" style="background-image:url(grass.webp);"></button>
    <button id="btnLava"  class="btn1" style="background-image:url(lava1.webp);"></button>
    <button id="btnWater" class="btn1" style="background-image:url(water1.webp);"></button>
    <button id="btnCross" class="btn1" style="background-image:url(bridge.webp);"></button>
    <button id="btnToad"  class="btn1" style="background-image:url(happy1.webp);"></button>
    <button id="btnSwitch"  class="btn1" style="background-image:url(sourceoff.webp);"> </button>
    <button id="btnPlate"  class="btn1" style="background-image:url(plateoff.webp);"> </button>
    <button id="btnPeach"  class="btn1" style="background-image:url(peach1.webp); background-size:calc(var(--btnsize)/2); background-position:center;"> </button>
    <button id="btnQuestion"  class="btn1" style="background-image:url(question.webp);"> </button>
  </div>




  <script type="module">
    import {loadString,Sound,Animation,isKeyDown,Filmstrip} from "./utils.js";

    //=================================================
    // GAMEPLAY VARIABLES AND FUNCTIONS
    //=================================================
    const ON=1,FRESH=2,CONDUCTING=4,SOURCE=8,GATE=16
    const WALL=1,VOID=2,LAMP=3,
        PEACH=4,PEACH_BURNING=5,BOWSER=6,BOWSER_BURNING=7,ASHES=8,
        PLATE=9,QUESTION=128
    const PLAYING=0,BOWSER_DIED=1,PEACH_DIED=-1,MARIO_DIED=-2
    const BRUSH_GRASS=0,BRUSH_LAVA=1,BRUSH_WATER=2,BRUSH_CROSS=3,BRUSH_TOAD=4,BRUSH_WALL=5,BRUSH_SWITCH=6,BRUSH_PLATE=7,BRUSH_PEACH=8,BRUSH_QUESTION=9
    const DIRS=[[1,0],[-1,0],[0,1],[0,-1]]
    
    let X,Y // level size
    let xCursor,yCursor  // cursor (Mario) position
    let ground,groundNew,subway,subwayNew,extras // level map
    let lastDirWalked,stalled=false
    let helpTexts=[],helpText=''
    let winlose=PLAYING 
    let preconverge=100,cheating=false,brush=0
    const starSize=2.0 // can make this a TOADML flag
    let joyForce=0
    let timeoutID

    function setPos(xnew,ynew) {xCursor=xnew;yCursor=ynew;xCurNext=xCursor;yCurNext=yCursor}
    function tryWalk(dir) {
      if (marioOrientation!=dir) {marioOrientation=dir; stalled=true; timeoutID=setTimeout(()=>stalled=false,50); return true} // Mario changes direction
      if (stalled) return false // already got stuck going in that direction
      stalled=false; 
      //======== Check for various cases including collisions with objects
      if (xCurNext!=xCursor || yCurNext!=yCursor) return false // Previous walk in progress; do nothing
      //======== Check for transition to next/prev level
      const dx=DIRS[dir][0],dy=DIRS[dir][1]
      let xnew=xCursor+dx,ynew=yCursor+dy
      if (xnew<=-1 && level>0) {setLevel(level-1); return}
      if (xnew>=X && winlose!=PEACH_DIED) {setLevel(level+1); return} // Advance level provided that Peach didn't die
      if (xnew<0||xnew>=X||ynew<0||ynew>=Y) {soundBuzz.play(); stalled=true; return false} // Illegal move
      const G=ground[xnew+X*ynew],H=extras[xnew+X*ynew],SCUR=subway[xCursor+X*yCursor],SNEW=subway[xnew+X*ynew]
      if (SCUR!=0 & (dy!=0)) {soundBuzz.play(); stalled=true; return false}  // Mario can't jump off bridge
      if (SNEW!=0 & (dy!=0)) {soundBuzz.play(); stalled=true; return false}  // Mario can't walk into subway tunnel
      if (H==VOID) {soundBuzz.play(); stalled=true; return false} // Can't walk into void
      if (H==WALL) {soundBuzz.play(); stalled=true; return false} // Can't walk into wall
      if (H>=QUESTION) { // Mario bumps a Question block
        soundCoin.play(); openHelp(H-QUESTION); helpDiv.focus(); stalled=true; return false
      }
      if ((G & SOURCE) && H!=PLATE) {  // Mario bumps a P Switch (not a plate)
        soundTock.play(); ground[xnew+X*ynew] ^= ON  // Toggle the ON/OFF state
        stalled=true; return false
      }
      if (G & GATE) { // Mario bumps a toad
        if (G & ON) {soundOw.play()} else soundHoo.play(); // Play appropriate sound
        ground[xnew+X*ynew] ^= ON; stalled=true; return false            // Toggle the toad state
      }
      //======== No obstacles; start walking!
      soundTock.play(); setTimeout(()=>soundTock.play(),130); 
      // console.log(nWalk,xMario,yMario,stalled)
      xCurNext=xnew; yCurNext=ynew; 
      tWalk=Date.now(); return true
    }
    function faceW() {marioOrientation=1}
    function faceE() {marioOrientation=0}
    function faceN() {marioOrientation=3}
    function faceS() {marioOrientation=2}
    function walkW() {tryWalk(1)}
    function walkE() {tryWalk(0)}
    function walkN() {tryWalk(3)}
    function walkS() {tryWalk(2)}
    function resetButtonStyles() {
      btnLava.className="btn1"
      btnWater.className="btn1"
      btnCross.className="btn1"
      btnToad.className="btn1"
      btnGrass.className="btn1"
      btnWall.className="btn1"
      btnSwitch.className="btn1"
      btnPlate.className="btn1"
      btnPeach.className="btn1"
      btnQuestion.className="btn1"
    }
    function selectLava()  {brush=BRUSH_LAVA; resetButtonStyles(); btnLava.className="btn1s"}
    function selectWater() {brush=BRUSH_WATER; resetButtonStyles(); btnWater.className="btn1s"}
    function selectCross() {brush=BRUSH_CROSS; resetButtonStyles(); btnCross.className="btn1s"}
    function selectToad()  {brush=BRUSH_TOAD; resetButtonStyles(); btnToad.className="btn1s"}
    function selectGrass() {brush=BRUSH_GRASS; resetButtonStyles(); btnGrass.className="btn1s"}
    function selectWall()  {brush=BRUSH_WALL; resetButtonStyles(); btnWall.className="btn1s"}
    function selectSwitch() {brush=BRUSH_SWITCH; resetButtonStyles(); btnSwitch.className="btn1s"}
    function selectPlate()  {brush=BRUSH_PLATE; resetButtonStyles(); btnPlate.className="btn1s"}
    function selectPeach()  {brush=BRUSH_PEACH; resetButtonStyles(); btnPeach.className="btn1s"}
    function selectQuestion()  {brush=BRUSH_QUESTION; resetButtonStyles(); btnQuestion.className="btn1s"}
    function setCheating(c) {
      if (c) {cheating=true; divPalette.style.visibility='visible'}
      else   {cheating=false; divPalette.style.visibility='hidden'}
    }
    function toggleCheating() { setCheating(!cheating) }
    function extract(tag, source) {
      const re = new RegExp('\\s+<' + tag + '>(.*?)<\/' + tag + '>', 'gs')
      const match = re.exec(source)
      if (match) return [match[1], source.replace(re,'')]
      else return ["", source]
    }
    function extractAll(tag, source) {
      const re = new RegExp('\\s+<' + tag + '>(.*?)<\/' + tag + '>', 'gs')
      const matches = source.matchAll(re)
      return [Array.from(matches, (m) => m[0]), source.replace(re,'')]
    }

    function setLevel(newLevel) {
      //============================== If you're in sandbox mode, SAVE before changing level!
      if (levelName.trim()=='SANDBOX') {
        localStorage.setItem('ground', JSON.stringify(ground))
        localStorage.setItem('subway', JSON.stringify(subway))
        localStorage.setItem('extras', JSON.stringify(extras))
      }
      //==============================
      stalled=true           // Don't ever start a new level while walking
      if (newLevel<0) return // if new level number is illegal, don't load it
      if (newLevel>=levelMaps.length) newLevel=levelMaps.length-1
      level = newLevel
      loadLevel(levelMaps[level])
      setScaling()
      btnPrev.disabled = (level==0)             // if current level is 0, disable "Previous Level" button
      btnNext.disabled = (level==levelMaps.length-1) // if we are on last level, disable "Next Level" button
      btnReset.style.animation = ""
      localStorage.setItem("storedLevel", level)
      document.activeElement.blur()  // remove focus from whatever button was pressed
    }
    function prevLevel() {setLevel(level-1)} 
    function nextLevel() {setLevel(level+1)} 
    function resetLevel() {setLevel(level)}
    function loadLevel(levelMap) {
      // console.log(level)
      // console.log(levelMap)
      preconverge=100; cheating=false; helpText='Level '+level  // defaults
      {
        const [content,remainder]=extract('timestep', levelMap); levelMap=remainder
        if(content) {
          timeStepInMilliseconds = Number(content)
          sliderSpeed.value = timeStepInMilliseconds
          divSpeed.innerText='DELAY '+timeStepInMilliseconds
        }
      }
      {const [content,remainder]=extract('name', levelMap); levelMap=remainder;levelName=content}
      {const [content,remainder]=extract('preconverge', levelMap); levelMap=remainder; if(content) preconverge=Number(content)}
      {const [content,remainder]=extract('cheat', levelMap); levelMap=remainder; if(content) cheating=Number(content)}
      {const [contents,remainder]=extractAll('help', levelMap); levelMap=remainder; if(contents) helpTexts=contents}

      if (levelName) {title.innerHTML=levelName; title.style.display='block'}
      else           {title.style.display='none'}
      setCheating(cheating)
      
      let rows = /<levelmap>\s*?[\r\n](.*?)<\/levelmap>/gs . exec(levelMap)
      try { rows = rows[1] } catch (e) { rows = '####M####'}
      rows = rows.split(/[\r\n]/).filter(i=>i)
      //-------- DETERMINE MAP SIZE AND ALLOCATE ARRAYS
      X = Math.max(...rows.map(s=>s.length)) // length of longest line
      Y = rows.length 
      ground   = new Uint8Array(X*Y)
      groundNew= new Uint8Array(X*Y)
      subway   = new Uint8Array(X*Y)
      subwayNew= new Uint8Array(X*Y)
      extras   = new Uint8Array(X*Y)
      //-------- POPULATE ARRAYS
      let nQuestions=0
      for (let y=0; y<Y; ++y) {
        for (let x=0; x<rows[y].length && x<X; ++x) {
          let g
          switch (rows[y][x]) {
            case '.': g=0; break   // grass
            case ' ': g=0; extras[x+X*y]=VOID; break   // void
            case 'W': g=0; extras[x+X*y]=WALL; break   // wall
            case '_': g=SOURCE|FRESH; extras[x+X*y]=PLATE; break // pressure plate
            case '#': g=CONDUCTING; break           // dirt
            case 'H': g=CONDUCTING|ON|FRESH; break
            case 's': g=SOURCE|FRESH;    break 
            case 'S': g=SOURCE|FRESH|ON; break 
            case 'n': g=GATE;    break // NOR gate, initially off?
            case 'N': g=GATE|ON; break // NOR gate, initially off?
            case '+': g=CONDUCTING; subway[x+X*y]=CONDUCTING; break // crossing
            case 'L': g=CONDUCTING; extras[x+X*y]=LAMP; break // Lamp
            case 'P': g=CONDUCTING; extras[x+X*y]=PEACH; break // Peach starts unburned
            case 'B': g=CONDUCTING; extras[x+X*y]=BOWSER; break // Bowser starts unburned
            case '?': g=0; extras[x+X*y]=QUESTION+nQuestions; ++nQuestions; break // Question block
            case 'r': g=SOURCE|FRESH|(Math.random()<.5?ON:0); break 
            default: g=0
          }
          ground[x+X*y]=g
        }
      }
      //-------- GAMEPLAY: PRE-CONVERGE TO STEADY STATE PREVENT PREMATURE BOWSER_DIED
      Sound.masterVolume = 0 // don't play annoying toad sounds while preconverging
      for (let iter=0; iter<preconverge; ++iter) evolve()
      Sound.masterVolume = 1
       //-------- GAMEPLAY: LOAD PEACHES AND BOWSERS AGAIN (IN CASE THEY GOT BURNED DURING PRE-CONVERGENCE)
      for (let y=0; y<rows.length; ++y) {
        for (let x=0; x<rows[y].length && x<X; ++x) {
          switch (rows[y][x]) {
            case 'P': ground[x+X*y]=CONDUCTING; extras[x+X*y]=PEACH; break // Peach starts unburned
            case 'B': ground[x+X*y]=CONDUCTING; extras[x+X*y]=BOWSER; break // Bowser starts unburned            
          }
        }
      }
      //-------- GAMEPLAY: IDENTIFY START POSITION
      for (let y=0; y<Y; ++y) for (let x=0; x<X; ++x) if (rows[y][x]=='M') setPos(x,y)
      xShaking=0; yShaking=0; tCur=0; winlose=PLAYING


      //-------- SPECIAL CASE: IF WE'RE IN SANDBOX LEVEL, LOAD SAVED DATA
      if (levelName.trim()=="SANDBOX") {
        const _ground = localStorage.getItem("ground")
        const _subway = localStorage.getItem("subway")
        const _extras = localStorage.getItem("extras")
        if (_ground) {
          ground = JSON.parse(_ground)
          subway = JSON.parse(_subway)
          extras = JSON.parse(_extras)
        } 
      }
      
    }
    //===============================================
    // evolve(): EVOLVE CELLULAR AUTOMATON
    //===============================================
    function evolve() {

      //======== Calculate groundNew[...] 
      for (let y=1; y<Y-1; ++y) for (let x=1; x<X-1; ++x) {
        const G=ground[x+X*y]
        groundNew[x+X*y]=G 
        if (extras[x+X*y]==PLATE) { //Pressure plate acts as SOURCE ON or SOURCE OFF depending
          // on whether it is being stepped on
          if (xCursor==x&&yCursor==y) groundNew[x+X*y]=SOURCE|FRESH|ON
          else                        groundNew[x+X*y]=SOURCE|FRESH
          continue
        }
        if (G&SOURCE) {groundNew[x+X*y]=G;         continue} // Source persists unchanged 
        if (G&FRESH)  {groundNew[x+X*y]=G & ~FRESH;continue} // Fresh cell goes stale
        //======== We need to consider neighbors
        let E=ground[(x+1)+X*y]
        let W=ground[(x-1)+X*y]
        
        let N,S;
        if (subway[x+X*y]) {N=0; S=0} // If subway exists, then ground has no N and S neighbors
        else {
          // If North neighbor has a subway, use the subway value; otherwise use ground value
          N=subway[x+X*(y-1)]; if(N==0) N=ground[x+X*(y-1)]
          S=subway[x+X*(y+1)]; if(S==0) S=ground[x+X*(y+1)]
        }
        // N=ground[x+X*(y-1)]
        // S=ground[x+X*(y+1)]        
        //======== If cell is a NOR gate, do NOR logic
        if (G&GATE) {
          // within this code block, if N and S neighbors are gates, they do NOT count as inputs
          if (N&GATE) N=0
          if (S&GATE) S=0
          let EE=E&(CONDUCTING|SOURCE)
          let WW=W&(CONDUCTING|SOURCE|GATE)
          let NN=N&(CONDUCTING|SOURCE)
          let SS=S&(CONDUCTING|SOURCE)

          if      ( !WW && !NN && !SS ) continue                              // gate has no inputs
          else if ( !(W&ON) && !(N&ON) && !(S&ON)) groundNew[x+X*y] = GATE|ON // all inputs are OFF
          else if (  WW&&(W&ON)  || NN&&(N&ON)  || SS&&(S&ON) ) groundNew[x+X*y] = GATE&~ON

          if      (G&ON && !(groundNew[x+X*y]&ON)) soundOw.play();    // gate switched OFF
          else if (!(G&ON) && (groundNew[x+X*y]&ON)) soundHoo.play(); // gate switched ON
          continue
        }
        //======== Cell is a normal conducting cell.  Check if any neighbors are FRESH, and if so, are they ON or OFF
        if (G&CONDUCTING) {
          // let flag=false,env=0 // env is the sum of +1's or -1's for each neighbor
          // if (W & GATE ) {flag=true; env+=(W&ON)?1:-1}


          // THIS OLD LOGIC IS WRONG
          // if (E & FRESH) {flag=true; env+=(E&ON)?1:-1}
          // if (W & FRESH) {flag=true; env+=(W&ON)?1:-1}
          // if (N & FRESH) {flag=true; env+=(N&ON)?1:-1}
          // if (S & FRESH) {flag=true; env+=(S&ON)?1:-1}
          // if (flag) { // Check whether we end up flipping state
          //   if      (!(G&ON) && env>=0) groundNew[x+X*y] = G | ON | FRESH
          //   else if ((G&ON) && env<=0) groundNew[x+X*y] = (G & (~ON)) | FRESH  
          // }


          // if cell is OFF and any neighbor is FRESH ON, turn on
          if (!(G&ON)) {
            if (
              (E&FRESH) && (E&ON)
            ||(W&FRESH) && (W&ON)
            ||(N&FRESH) && (N&ON)
            ||(S&FRESH) && (S&ON) ) groundNew[x+X*y] = G | ON | FRESH
          }
          else { 
            if (
              (E&FRESH) && !(E&ON)
            ||(W&FRESH) && !(W&ON)
            ||(N&FRESH) && !(N&ON)
            ||(S&FRESH) && !(S&ON) ) groundNew[x+X*y] = (G & (~ON)) | FRESH  
          }

          

          if (W & GATE) groundNew[x+X*y] = CONDUCTING | (W&ON) | FRESH // if fed by a gate, MUST be fresh - overrides prev.
        
          //======== Special handling: PEACH and BOWSER are absorbers (cannot be FRESH)
          // Also, if PEACH or BOWSER are already set on fire, they cannot be extinguished
          let H=extras[x+X*y]
          if (H==PEACH || H==BOWSER) {
            groundNew[x+X*y] &= ~FRESH
            if (ground[x+X*y]&ON)  groundNew[x+X*y] |= ON
          }
          continue
        }
      }

      //======== Calculate subwayNew[...] based on NORTH and SOUTH neighbors only
      for (let y=1; y<Y-1; ++y) for (let x=1; x<X-1; ++x) {
        const H = subway[x+X*y]
        subwayNew[x+X*y] = H // default: same

        if (!H) continue  // not a crossing
        if (H&FRESH)  {subwayNew[x+X*y]=H & ~FRESH;continue} // Fresh cell goes stale

        const N=subway[x+X*(y-1)] ? subway[x+X*(y-1)] : ground[x+X*(y-1)]
        const S=subway[x+X*(y+1)] ? subway[x+X*(y+1)] : ground[x+X*(y+1)]
        let flag=false,env=0 // env is the sum of +1's or -1's for each neighbor  
        if (N & FRESH) {flag=true; env+=(N&ON)?1:-1}
        if (S & FRESH) {flag=true; env+=(S&ON)?1:-1}
        if (flag) { // Check whether we end up flipping state
          if      (!(H&ON) && env>=0) subwayNew[x+X*y] = H | ON | FRESH
          else if ( (H&ON) && env<=0) subwayNew[x+X*y] = (H & (~ON)) | FRESH  
        }
      }
      
      //======== Do synchronous updates on ground and subway
      for (let y=1; y<Y-1; ++y) for (let x=1; x<X-1; ++x) ground[x+X*y]=groundNew[x+X*y]
      for (let y=1; y<Y-1; ++y) for (let x=1; x<X-1; ++x) subway[x+X*y]=subwayNew[x+X*y]
    }



    //=======================================================
    // UTILITIES
    //=======================================================
    const clamp=(x,a,b) => Math.min(Math.max(x,a),b)
    // function log(s) { statusBar.innerText += ' '+s+'\n' }
    //=================================================
    // GRAPHICS (VARIABLES AND FUNCTIONS)
    //=================================================
    const ctx=canvas.getContext('2d')
    let winWid,winHei,cellsize
    let marioOrientation=2 // start game facing South
    // let xCurPrev,yCurPrev  // variables associated with Mario's
    let xCurNext,yCurNext  // variables associated with Mario's
    let xMario,yMario,nWalk=0,tWalk=0 // appearance (but not gameplay)
    let tCur=0,tMario=0,tPeach=0,tBowser=0
    let timeOfLastFrame=0
    let timeStepInMilliseconds = 1000/60.  //300.
    let level=0,levelName='' // current level
    let xShaking=0,yShaking=0

    function setScaling() {
      winWid=visualViewport.width||window.innerWidth||document.documentElement.clientWidth||document.body.clientWidth
      winHei=visualViewport.height||window.innerHeight||document.documentElement.clientHeight||document.body.clientHeight
      let availWidth =clamp(winWid, 300, 3000) // set canvas width according to window width; warning: btnSize=48
      let availHeight=clamp(winHei*(1-.08), 300, 3000) // may reduce this
      cellsize=Math.min(Math.floor(availWidth/X),Math.floor((availHeight)/Y)) // for graphics
      canvas.width=X*cellsize
      canvas.height=Y*cellsize
      canvas.style.left = Math.floor((winWid-canvas.width)/2) + "px"
      title.style.left  = Math.floor((winWid-title.offsetWidth)/2) + "px"      
    }
    function render() {
      tCur += 1
      const a=cellsize // convenience ALIAS
      //======== DRAW BACKGROUND AND GAME AREA? NO      
      //======== DRAW TERRAIN
      ctx.lineWidth=2 //; ctx.font = '10px Arial'
      for (let y=0; y<Y; ++y) for (let x=0; x<X; ++x) {
        const g=ground[x+X*y]
        const s=subway[x+X*y]
        const frm=(tCur+4*x+13*y)/17

        if (s) { // if there is a subway, do special code
          ctx.clearRect(x*a,y*a,a,a)
          ctx.drawImage(imgMask, x*a,y*a,a,a)
          ctx.globalCompositeOperation = 'source-atop'
          if (s & ON)  animLava.draw(x*a, y*a, a, a, frm) // subway contains lava
          else         animWater.draw(x*a, y*a, a, a, frm)// subway contains water
          ctx.globalCompositeOperation = 'destination-over'
          if (g & ON)  animLava.draw(x*a, y*a, a, a, frm) // conducting, on
          else         animWater.draw(x*a, y*a, a, a, frm)// conducting, off
          ctx.globalCompositeOperation = 'source-over'
          ctx.drawImage(imgBridge, x*a,y*a,a,a)
          continue
        }

        if (g==0)          {ctx.drawImage(imgGrass, x*a,y*a,a,a) }
        else if (g & CONDUCTING) {
          if (g & ON)  animLava.draw(x*a, y*a, a, a, frm) // conducting, on
          else         animWater.draw(x*a, y*a, a, a, frm)// conducting, off
        }
        else if ((g & SOURCE) && extras[x+X*y]!=PLATE) {
          if (g & ON) {animLava.draw(x*a,y*a,a,a, frm); ctx.drawImage(imgSourceOn, x*a,y*a,a,a)} // P Switch on
          else        {animWater.draw(x*a,y*a,a,a,frm); ctx.drawImage(imgSourceOff, x*a, y*a, a, a)} // P Switch off
        }
        else if (g & GATE) {
          if (g & ON) { // gate is ON
            animWater.draw(x*a, y*a, a, a, frm)
            animHappy.draw(x*a,y*a,a,a, tCur/14)
          } else { // gate is OFF
            animWater.draw(x*a, y*a, a, a, frm)
            let N=subway[x+X*(y-1)] ? subway[x+X*(y-1)] : ground[x+X*(y-1)]
            let S=subway[x+X*(y+1)] ? subway[x+X*(y+1)] : ground[x+X*(y+1)]
            let W=ground[(x-1)+X*y]&ON
            if (ground[x+X*(y-1)] & GATE) N=0
            if (ground[x+X*(y+1)] & GATE) S=0
            if (W&ON) ctx.drawImage(imgLava, 0,0,12,24, x*a,y*a,a/2,a)
            if (N&ON) ctx.drawImage(imgLava, 0,0,24,12, x*a,y*a,a,a/2)
            if (S&ON) ctx.drawImage(imgLava, 0,12,24,12, x*a,y*a+a/2,a,a/2)
            animCrying.draw(x*a,y*a,a,a, tCur/15)
          }
        }        
      }

      //======== DRAW CERTAIN EXTRAS (VOIDS AND WALLS)
      for (let y=0; y<Y; ++y) for (let x=0; x<X; ++x) {
        switch (extras[x+X*y]) { 
          case VOID: ctx.fillStyle='#000';ctx.fillRect(x*a, y*a, a, a); break // void
          case WALL: ctx.drawImage(imgBrick, x*a, y*a, a, a); break
        }
        if (extras[x+X*y]>=QUESTION) ctx.drawImage(imgQuestion, x*a,y*a,a,a)
      }
      //======== DRAW CERTAIN EXTRAS (QUESTION BLOCKS, LAMPS, ETC.)
      let size,xcen,ycen,sx,sy
      for (let y=0; y<Y; ++y) for (let x=0; x<X; ++x) {
        const frm=(tCur+4*x+13*y)/20
        switch (extras[x+X*y]) {
          case WALL: break; // this was done in the earlier loop
          case PLATE:
            if (ground[x+X*y] & ON) {animLava.draw(x*a,y*a,a,a, frm);ctx.drawImage(imgPlateOn, x*a,y*a,a,a)}
            else                   {animWater.draw(x*a,y*a,a,a, frm);ctx.drawImage(imgPlateOff, x*a,y*a,a,a)}
            break
          case LAMP:
            xcen=(x+.5)*a; ycen=(y+.5)*a
            if (ground[x+X*y]&ON) {
              if ((Math.floor(tCur/10)%2)) {sx=1.05*starSize*a; sy=sx}
              else                         {sx=starSize*a; sy=sx}
              ctx.drawImage(imgStarOn, xcen-sx/2, ycen-sy/2, sx,sy)
              // should remake this into an Animation
            }
            else {
              sx=starSize*a; sy=sx
              ctx.drawImage(imgStarOff,  xcen-sx/2, ycen-sy/2, sx,sy)
            }
            break
          case PEACH:
            sy=a,sx=a/animPeach.aspect
            xcen=(x+.5)*a,ycen=(y+.5)*a
            animWater.draw(x*a, y*a, a, a, frm)   
            animPeach.draw(xcen-sx/2, ycen-sy/2, sx,sy, tCur/41)                 
            break
          case PEACH_BURNING:
            if (tPeach<80) {xShaking+=Math.cos(tPeach*.6)*2; yShaking=Math.sin(tPeach*.3)*10 }
            else {xShaking=0; yShaking+=(tPeach-80)*.15}
            if (tPeach<150) {
              animLava.draw(x*a, y*a, a, a, frm)
              sy=a,sx=a/animPeach.aspect
              xcen=(x+.5)*a + xShaking,ycen=(y+.5)*a + yShaking
              ctx.save(); // Save current canvas state
              ctx.translate(xcen,ycen); // Translate to the center of the image
              ctx.rotate(tPeach*.1); // Rotate  by radians
              animPeach.draw(-sx/2, -sy/2, sx, sy, tCur/17)
              ctx.restore(); // Restore the canvas to its original state
            }
            else { //Peach has become ashes, is now safe to walk on (not that it matters)
              ground[x+X*y] = 0; extras[x+X*y] = ASHES
            }
            ++tPeach
            break
          case BOWSER:
            size=Math.trunc(a*1.5),xcen=(x+.5)*a,ycen=(y+.5)*a
            animWater.draw(x*a, y*a, a, a, frm)
            fsBowser.draw(Math.trunc(xcen-size/2), Math.trunc(ycen-size/2), size,size, tCur/10)
            break
          case BOWSER_BURNING:
            animLava.draw(x*a, y*a, a, a, frm)
            size=a*1.5,xcen=(x+.5)*a+xShaking,ycen=(y+.5)*a+yShaking
            if (tBowser<80) {xShaking+=Math.cos(tBowser*.9)*2; yShaking=Math.sin(tBowser*.6)*10 }
            else {xShaking=0; yShaking+=(tBowser-80)*.15}
            if (tBowser<150) {
              fsBowser.draw(xcen-size/2, ycen-size/2, size,size, tCur/10)
            }
            else { // Bowser has become ashes, is now safe to walk on
              ground[x+X*y] = 0; extras[x+X*y] = ASHES
            }
            ++tBowser
            break
          case ASHES:
            ctx.drawImage(imgDirt, x*a,y*a,a,a);animAsh.draw(x*a,y*a,a,a,tCur/10)
            break
        }
      }
      //======== DRAW MARIO
      if (winlose==MARIO_DIED) {
        // Mario is burned (dead)
        const x=xCursor,y=yCursor
        const xcen=(x+.5)*a+xShaking,ycen=(y+.5)*a+yShaking,sx=a,sy=a
        ctx.drawImage(imgMarioDead, xcen-sx/2, ycen-sy/2, sx,sy);

        if (tMario<100) {xShaking+=Math.cos(tMario*1.2)*2; yShaking=Math.sin(tMario*.7)*10 }
        else {xShaking=0; yShaking+=(tMario-20)*.03}      
        ++tMario
      } else {
        const maxWalkSteps = 6
        if (xCursor!=xCurNext||yCursor!=yCurNext) nWalk = Math.floor(((Date.now() - tWalk))/17) // 17 ms per frame
        if (nWalk>=maxWalkSteps) {xCursor=xCurNext; yCursor=yCurNext; nWalk=0} // go back to standing still
        xMario = xCursor + (xCurNext-xCursor)*nWalk/maxWalkSteps
        yMario = yCursor + (yCurNext-yCursor)*nWalk/maxWalkSteps
        
        //let asp=imgMarioE.height/imgMarioE.width;
        ctx.imageSmoothingEnabled = false
        const xcen=(xMario+.5)*a,ycen=(yMario+.5)*a,sx=a,sy=a //,sy=a,sx=sy/asp
        switch (marioOrientation) {
          case 0: animMarioE.draw(xcen-sx/2, ycen-sy/2, sx,sy, nWalk); break
          case 1: animMarioW.draw(xcen-sx/2, ycen-sy/2, sx,sy, nWalk); break
          case 2: animMarioS.draw(xcen-sx/2, ycen-sy/2, sx,sy, nWalk); break
          case 3: animMarioN.draw(xcen-sx/2, ycen-sy/2, sx,sy, nWalk); break
        }
      }
      //======== DEBUGGING
      // if (cheating) {
      //   for (let y=0; y<Y; ++y) for (let x=0; x<X; ++x) { 
      //     ctx.fillStyle='#fff'
      //     ctx.font = 'bold 16px sans-serif'
      //     ctx.fillText(ground[x+X*y],  (x+.5)*a, (y+.25)*a)
      //     ctx.fillStyle='#ff0'
      //     ctx.fillText(extras[x+X*y],  (x+.5)*a, (y+.75)*a)
      //   }
      // }
    }
    
    function checkVictory() {
      //title.innerHTML = ''+winlose // TEMPORARY DEBUGGING
      // title.innerHTML = ''+tBowser
      if (cheating) return // can't lose in cheat mode

      for (let y=0; y<Y; ++y) for (let x=0; x<X; ++x) {
        // if (winlose!=BOWSER_DIED && extras[x+X*y]==BOWSER && ground[x+X*y]&ON) {
        if (extras[x+X*y]==BOWSER && ground[x+X*y]&ON) {
          tBowser=0; soundBowsFall.play() // play Bowser death sound
          extras[x+X*y]=BOWSER_BURNING

          if (winlose==PLAYING) {
            setTimeout( ()=>soundWin.play(), 1000) // play victory sound
            winlose=BOWSER_DIED
          }
          break
        }
        if (winlose!=PEACH_DIED && extras[x+X*y]==PEACH && ground[x+X*y]&ON) {
          extras[x+X*y]=PEACH_BURNING
          tPeach=0
          if (winlose==PLAYING) { // don't celebrate if mraio or peach is already dead
            soundLose.play(); 
            setTimeout(()=>btnReset.style.animation = 'flashingAnimation 0.5s step-start infinite', 500)
          }
          winlose=PEACH_DIED
          break
        }
      }
      if (winlose!=MARIO_DIED &&
        ((ground[xCursor+X*yCursor]&ON) && extras[xCursor+X*yCursor]!=PLATE     // Mario got burned in lava
        || (extras[xCursor+X*yCursor]==BOWSER && winlose!=BOWSER_DIED))   // Mario got spiked by Bowser
      ) {
        soundLose.play()
        setTimeout(()=>btnReset.style.animation = 'flashingAnimation 0.5s step-start infinite', 500)
        tMario=0
        winlose=MARIO_DIED
      }
    } 
    function animate(timeCurrent) {
      requestAnimationFrame(animate)
      render() 
      checkVictory()
      
      if      (isKeyDown('a')||isKeyDown('A')||isKeyDown('ArrowLeft')) walkW()
      else if (isKeyDown('d')||isKeyDown('D')||isKeyDown('ArrowRight')) walkE()
      else if (isKeyDown('w')||isKeyDown('W')||isKeyDown('ArrowUp')) walkN()
      else if (isKeyDown('s')||isKeyDown('S')||isKeyDown('ArrowDown')) walkS()
      else { // process joystick ONLY if keyboard is not active
        joyForce = Math.hypot(joyX,joyY) 
        if (joyForce<5) { // weak force, do nothing
        }
        else if (joyForce>10) { //strong force, walk
          if (Math.abs(joyX)>Math.abs(joyY)) if (joyX>0) {walkE()} else walkW()
          else                         if (joyY>0) {walkS()} else walkN()
        }
        else { // medium force, change direction only
          if (Math.abs(joyX)>Math.abs(joyY)) if (joyX>0) {faceE()} else faceW()
          else                         if (joyY>0) {faceS()} else faceN()
        }
      }
  
      const elapsed = Date.now() - timeOfLastFrame
      if (elapsed <= timeStepInMilliseconds) return
      timeOfLastFrame = Date.now()
      evolve()
    }

    //=================================================
    // HELP
    //=================================================
    function closeHelp() {helpDiv.style.display="none"}
    function openHelp(nQuestion) {
      winWid=window.innerWidth||document.documentElement.clientWidth||document.body.clientWidth
      winHei=window.innerHeight||document.documentElement.clientHeight||document.body.clientHeight
      const wid=winWid - 64
      const hei=winHei - 64
      helpDiv.style.display = "block"
      helpDiv.innerHTML = helpTexts[nQuestion]
      helpDiv.onclick = closeHelp
      helpDiv.focus()
      // let utterance = new SpeechSynthesisUtterance(convertHtmlToText(helpText))
      // utterance.pitch = 8.0
      // utterance.rate = 3.0
      // speechSynthesis.speak(utterance)
    }
    //=================================================
    // INTERACTIVITY
    //=================================================
    function keyDown(e) {
      if (timeoutID) {clearTimeout(timeoutID); timeoutID=null}
      
      if (helpDiv.style.display=="block") {helpDiv.style.display="none"; return}

      if (e.ctrlKey||e.altKey) return // don't trap browser shortcuts involving Ctrl or Alt
      let processed=true
      switch (e.key) {
        case '[': prevLevel(); break
        case ']': nextLevel(); break
        // case 'h':case'H':if(cheating) selectLava(); break    // add hot burning
        // case 'j':case'J':if(cheating) selectWater(); break    // add cold burning
        // case 'k':case'K':if(cheating) selectCross(); break // toggle crossing
        // case 'l':case'L':if(cheating) selectToad(); break    // add NOR gate (Toad)
        // case ';':case';':if(cheating) selectGrass(); break // erase current ground  //case 'Backspace': case 'Delete':                 
        case 'C': toggleCheating(); break
        case 'R': resetLevel(); break    // reset level
        default: processed=false
      }
      if (processed) {e.preventDefault(); e.stopPropagation(); }
    }
    function keyUp(e) {
      if (timeoutID) {clearTimeout(timeoutID); timeoutID=null}
      stalled=false
    }
    let joyAnchorX,joyAnchorY,joyX=0,joyY=0;
    function joyTouchStart(e) {
      e.preventDefault()
      // joyAnchorX=event.touches[0].pageX // not appropriate
      // joyAnchorY=event.touches[0].pageY
      const rect = joyring.getBoundingClientRect()
      joyAnchorX = (rect.left + rect.right)/2
      joyAnchorY = (rect.top + rect.bottom)/2
      
      // console.log([joyAnchorX,joyAnchorY])
      // console.log([event.touches[0].clientX,event.touches[0].clientY])

      joyX=clamp(event.touches[0].clientX-joyAnchorX,-30,30)
      joyY=clamp(event.touches[0].clientY-joyAnchorY,-30,30)
      // joystick.style.transform=`translate(${joyX}px,${joyY}px)`
      joyForce = Math.hypot(joyX,joyY) // decide whether to walk ONE STEP
      if (joyForce<5) { // weak force, do nothing
      }
      else if (joyForce>10) { //strong force, walk
        if (Math.abs(joyX)>Math.abs(joyY)) if (joyX>0) {walkE()} else walkW()
        else                         if (joyY>0) {walkS()} else walkN()
      }
      else { // medium force, change direction only
        if (Math.abs(joyX)>Math.abs(joyY)) if (joyX>0) {faceE()} else faceW()
        else                         if (joyY>0) {faceS()} else faceN()
      }
    }
    function joyTouchMove(e) {
      e.preventDefault()
      joyX=clamp(event.touches[0].clientX-joyAnchorX,-30,30)
      joyY=clamp(event.touches[0].clientY-joyAnchorY,-30,30)
      // joystick.style.transform=`translate(${joyX}px,${joyY}px)`
    }
    function joyTouchEnd(e) {
      joyX=0; joyY=0
      // joystick.style.transform='translate(0,0)'
      stalled=false
    }


    function paint(x, y) { // overwrite cell using current brush
      if(!cheating) return
      if (x>=0&&x<X&&y>=0&&y<Y) {
        soundCoin.play()  // should add logic so that sound only plays if the map is actually changed
        switch (brush) {
          case BRUSH_GRASS: subway[x+X*y]=extras[x+X*y]=0; ground[x+X*y]=0; break
          case BRUSH_LAVA:  subway[x+X*y]=extras[x+X*y]=0; ground[x+X*y]=CONDUCTING|FRESH|ON; break
          case BRUSH_WATER: subway[x+X*y]=extras[x+X*y]=0; ground[x+X*y]=CONDUCTING|FRESH; break
          case BRUSH_WALL:  subway[x+X*y]=0; ground[x+X*y]=0; extras[x+X*y]=WALL; break
          case BRUSH_TOAD:
            if (ground[x+X*y] & GATE) {ground[x+X*y]^=ON}
            else {subway[x+X*y]=extras[x+X*y]=0; ground[x+X*y]=GATE|ON}
            break
          case BRUSH_SWITCH:
            if (ground[x+X*y] & SOURCE) {ground[x+X*y]^=ON}
            else {subway[x+X*y]=0; ground[x+X*y]=SOURCE|FRESH;extras[x+X*y]=0;}     
            break
          case BRUSH_PLATE: subway[x+X*y]=0; ground[x+X*y]=SOURCE|FRESH;extras[x+X*y]=PLATE; break
          case BRUSH_CROSS:
            if(subway[x+X*y]) {subway[x+X*y]=0; if (!ground[x+X*y]) ground[x+X*y]=CONDUCTING} // REMOVE SUBWAY
            else {subway[x+X*y]=CONDUCTING|FRESH; ground[x+X*y]|=CONDUCTING|FRESH}  // ADD SUBWAY
            break
          case BRUSH_PEACH: subway[x+X*y]=0; ground[x+X*y]=CONDUCTING; extras[x+X*y]=PEACH; break
          case BRUSH_QUESTION: subway[x+X*y]=0; ground[x+X*y]=0; extras[x+X*y]=QUESTION; break
        }
      }
    }
    let mouseIsDown = false
    function canvasMouseDown(e) {
      e.preventDefault(); e.stopPropagation()
      const rect=canvas.getBoundingClientRect()
      paint(Math.floor((e.clientX - rect.left)/cellsize), Math.floor((e.clientY - rect.top)/cellsize))
    }
    function canvasMouseMove(e) {
      if (!e.buttons) return
      e.preventDefault(); e.stopPropagation()
      const rect=canvas.getBoundingClientRect()
      paint(Math.floor((e.clientX - rect.left)/cellsize), Math.floor((e.clientY - rect.top)/cellsize))
    }    
    function canvasTouchStart(e) {
      if (e.touches.length==1) {e.preventDefault(); e.stopPropagation()}
      const rect=canvas.getBoundingClientRect()
      paint(Math.floor((e.touches[0].clientX - rect.left)/cellsize), Math.floor((e.touches[0].clientY - rect.top)/cellsize))
    }
    function canvasTouchMove(e) {
      if (e.touches.length==1) {e.preventDefault(); e.stopPropagation()}
      const rect=canvas.getBoundingClientRect()
      paint(Math.floor((e.touches[0].clientX - rect.left)/cellsize), Math.floor((e.touches[0].clientY - rect.top)/cellsize))
    }
    

    function launchGame() {
      level = localStorage.getItem("storedLevel")
      if (level) {level=Number(level)} else level=0
      if (!level) level=0
      setLevel(level)
      setScaling()

      btnReset.addEventListener('click', resetLevel)
      btnPrev.addEventListener('click', prevLevel)
      btnNext.addEventListener('click', nextLevel)
      btnLava.addEventListener('click', selectLava)
      btnWater.addEventListener('click', selectWater)
      btnCross.addEventListener('click', selectCross)
      btnGrass.addEventListener('click', selectGrass)
      btnToad.addEventListener('click', selectToad)
      btnWall.addEventListener('click', selectWall)
      btnSwitch.addEventListener('click', selectSwitch)
      btnPlate.addEventListener('click', selectPlate)
      btnPeach.addEventListener('click', selectPeach)
      btnQuestion.addEventListener('click', selectQuestion)
      btnCheat.addEventListener('click', toggleCheating)
      document.body.removeEventListener('keydown', launchGame, false)

      window.addEventListener('resize', setScaling)
      window.visualViewport.addEventListener('resize', setScaling)

      document.body.addEventListener('dblclick', e=>e.preventDefault())
      document.body.addEventListener('keydown', keyDown)
      document.body.addEventListener('keyup', keyUp)
      canvas.addEventListener('touchstart', canvasTouchStart)
      canvas.addEventListener('touchmove', canvasTouchMove)
      canvas.addEventListener('mousedown', canvasMouseDown)
      canvas.addEventListener('mousemove', canvasMouseMove)
      joystick.addEventListener('touchstart', joyTouchStart)
      joystick.addEventListener('touchmove',  joyTouchMove)
      joystick.addEventListener('touchend',  joyTouchEnd)
      splashScreen.style.display = 'none' // Hide splash screen
      joystick.style.display = 'block' // Show
      canvas.style.display = 'block' // Show
      controls.style.display = 'block'
      sliderSpeed.oninput=()=>{
        timeStepInMilliseconds=Number(sliderSpeed.value);
        divSpeed.innerText='DELAY '+timeStepInMilliseconds
      }

      // window.addEventListener("beforeunload", function(e){
      //   return "Are you sure to leave this page?";
      // });

      selectWater()
      requestAnimationFrame(animate)
    }

    //===============================================
    // MAIN MODULE CODE
    //===============================================
    ctx.imageSmoothingEnabled = false   // don't antialias 
    Animation.ctx = ctx
    Filmstrip.ctx = ctx
    let animMarioE= new Animation([imgMarioE,imgMarioE2,imgMarioE3])
    let animMarioW= new Animation([imgMarioW,imgMarioW2,imgMarioW3])
    let animMarioN= new Animation([imgMarioN,imgMarioN2,imgMarioN,imgMarioN4])
    let animMarioS= new Animation([imgMarioS,imgMarioS2,imgMarioS,imgMarioS4])
    let animPeach = new Animation([imgPeach1,imgPeach2])
    let animLava  = new Animation([imgLava,imgLava2])
    let animWater = new Animation([imgWater,imgWater2])
    let animCrying= new Animation([imgCrying1,imgCrying2])
    let animHappy = new Animation([imgHappy1,imgHappy2])
    let animAsh   = new Animation([imgAsh1,imgAsh2])
    let fsBowser  = new Filmstrip(imgBowser1234, 32, 32)
    let soundTock = new Sound('tock.mp3'); soundTock.vol = .3
    let soundCoin = new Sound('coin.mp3')
    let soundBuzz = new Sound('buzz.mp3')
    let soundHoo = new Sound('hoo.mp3'); soundHoo.vol = .03
    let soundOw = new Sound('ow.mp3'); soundOw.vol = .03
    let soundBowsFall = new Sound('bowsfall.mp3')
    let soundLose = new Sound('lose.mp3')
    let soundWin = new Sound('win.mp3')
    let levelMaps = await loadString('maps.txt') // clear browser cache if this file is edited
    levelMaps = [...levelMaps.matchAll(  /<levelmap>.*?<\/levelmap>/gs )].map(i=>i[0])
    
    splashScreen.addEventListener('click', launchGame)
    document.body.addEventListener('keydown', launchGame, false)
  </script>
</body>
</html> 