<!DOCTYPE html>
<html>
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="icon" href="favicon.ico" type="image/x-icon">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link rel="preload" href="peach1.webp" as="image">
  <link rel="preload" href="peach2.webp" as="image">
  <link rel="preload" href="happy1.webp" as="image">
  <link rel="preload" href="happy2.webp" as="image">
  <link rel="preload" href="bowser.webp" as="image">
  <link rel="preload" href="grass.webp" as="image">
  <link rel="preload" href="dirt.webp" as="image">
  <link rel="preload" href="lava.webp" as="image">
  <!-- <link rel="preload" href="crying1.webp" as="image"> -->
  <!-- <link rel="preload" href="crying2.webp" as="image"> -->
  <!-- <link rel="preload" href="staron.webp" as="image"> -->
  <!-- <link rel="preload" href="staroff.webp" as="image"> -->
  <style>
    .gradient {
      height:300px; width:300px; border:1px solid black; font-size:30px;
      background: linear-gradient(130deg, #262626, #ff7e00, #fff200);
      background-size: 200% 200%;
      -webkit-animation: Animation 4s ease infinite;
      -moz-animation: Animation 4s ease infinite;
      animation: Animation 4s ease infinite;
    }   
    @-webkit-keyframes Animation {
      0%{background-position:10% 0%}
      50%{background-position:91% 100%}
      100%{background-position:10% 0%}
    }
    @-moz-keyframes Animation {
      0%{background-position:10% 0%}
      50%{background-position:91% 100%}
      100%{background-position:10% 0%}
    }
    @keyframes Animation { 
      0%{background-position:10% 0%}
      50%{background-position:91% 100%}
      100%{background-position:10% 0%}
    }
    /* @font-face {
      font-family: 'Titillium Web';
      font-style: normal;
      font-weight: 700;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/titilliumweb/v19/NaPDcZTIAOhVxoMyOr9n_E7ffHjDGItzYw.woff2) format('woff2');
      unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+0304, U+0308, U+0329, U+2000-206F, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
    } */
    @font-face {
      font-family: 'gameFont';
      src: url('Retro Gaming.ttf') format('truetype'); /* Specify the path to your .ttf file */
      font-weight: normal; /* Define the weight (e.g., normal, bold) */
      font-style: normal;  /* Define the style (e.g., normal, italic) */
    }
    :root {--btnsize:8vmin;}
    html,body { overflow: hidden;  /* don't use scrollbars ! */
      background-color:#333; padding:0; margin:0; width:100%; height:100%; font-family:'gameFont',sans-serif;}
    #title {position:absolute;top:2px;width:100%;padding:0;margin:0;text-align:center; font-size:3vmin; color:white;}
    button {cursor:pointer;
            float:left;margin:0;padding:0;text-align:center; border-radius:8px; font-family:'gameFont',sans-serif; 
            font-size: 4vmin;
            background-color:#666; color:white;
            background-repeat: no-repeat;}
    button:disabled {opacity:25%;}
    .btn1 { width:var(--btnsize); height:var(--btnsize); background-size:cover; 
            text-shadow: 2px 2px 3px black;
          } /* square button */
    .btn2 { width:calc(10vmin); height:var(--btnsize);margin:1px; padding:0; font-size: 2vmin;}
    .separator { height:16px; clear:left; }
  </style>
</head>
<body>
  <div id="splashScreen" class="gradient" style="width: 100%; height:100%; color:#FFF; text-align: center;">
  <div style="text-align: center; vertical-align:center; height:25%; font-size:12vmin;
  white-space: pre;"> T O A D   B U R N </div>
  <div style="text-align: center; height: 25%; font-size:6vmin;"> By Yen Lee Loh and Isaac Hutchison </div>
  <div style="text-align: center; height: 25%; font-size:4vmin;"> Loading... </div>
  </div>
  <!-- <audio><source src="tock.mp3"></audio>
  <audio><source src="buzz.ogg"></audio>
  <audio><source src="win1.ogg"></audio>
  <audio><source src="win2.ogg"></audio>
  <audio><source src="lose.ogg"></audio> -->
  <canvas id="canvas" style="position:absolute; top:0; left:0px;">Your browser does not support the HTML5 canvas tag.</canvas>
  <div id="title"></div>
  <div id="controls" style="position:absolute; bottom:0; left:0; width:100%; visibility:hidden;">
  <!-- <div id="controls" style="position:absolute; bottom:0; left:0; width:100%;"> -->
    <div style="float:left; width:calc(3*var(--btnsize));" id="movementKeypad">
      <!-- <div class="separator"></div> -->
      <button id="btnHelp"  class="btn1" style="background-image:url(question.webp);"></button>
      <button id="btnUp"    class="btn1" style="background-image:url(arrowU.svg);"> E </button>
      <button               class="btn1" style="visibility: hidden;">  </button>
      <button id="btnLeft"  class="btn1" style="background-image:url(arrowL.svg);"> S </button>
      <button id="btnDown"  class="btn1" style="background-image:url(arrowD.svg);"> D </button>
      <button id="btnRight" class="btn1" style="background-image:url(arrowR.svg);"> F </button>
    </div>
    <div style="float:left; margin:0ex 5ex 0ex 5ex;">
      <button id="btnPrev"  class="btn2" title="Key: [">       Prev </button>
      <button id="btnReset" class="btn2" title="Key: Shift-R"> Reset </button>
      <button id="btnNext"  class="btn2" title="Key: [">       Next  </button>
      <br>
      <button id="btnSlow"  class="btn2">Slow</button>
      <button id="btnFast"  class="btn2">Fast</button>
      <button id="btnCheat" class="btn2" title="Key: Shift-C"> Cheat</button>
    </div>
    <div style="position:absolute; bottom: 0; right:0; width:calc(5*var(--btnsize));" id="actionButtons">
      <button id="btnLava"  class="btn1" style="background-image:url(lava.webp);" disabled="disabled"> H </button>
      <button id="btnDirt"  class="btn1" style="background-image:url(dirt.webp);" disabled="disabled"> J </button>
      <button id="btnCross" class="btn1" style="background-image:url(crossing.webp);" disabled="disabled"> K </button>
      <button id="btnToad"  class="btn1" style="background-image:url(happy1.webp); color:#FFF;" disabled="disabled"> L </button>
      <button id="btnGrass" class="btn1" style="background-image:url(grass.webp);" disabled="disabled"> ; </button>
    </div>
  </div>
  <script type="module">
    //=======================================================
    // IMAGE, AUDIO, AND STRING LOADERS
    //=======================================================
    function loadImage(url) { 
      // console.log('Requesting', url)
      return new Promise((resolve,reject) => { 
        let image = new Image()
        image.onload  = ()=>resolve(image)
        // image.onload  = ()=>{console.log("Loaded"         ,url);resolve(image)}
        image.onerror = ()=>{console.log("Failed to load ",url);reject()      }
        image.src     = url
      })
    }
    function loadAudio(url) {
      // console.log('Requesting', url)
      return new Promise((resolve,reject) => { 
        let audio = new Audio(url)
        audio.oncanplaythrough = ()=>resolve(audio)
        //audio.oncanplaythrough = ()=>{console.log("Loaded"         ,url);resolve(audio)}
        audio.onerror          = ()=>{console.log("Failed to load ",url);reject()}
        // audio.addEventListener("canplaythrough", ()=>{console.log("Loaded", url); resolve(audio)})
      })
    }
    function loadString(url) {
      // console.log('Requesting', url)
      return fetch(url).then(r=>r.text()) 
    }
    //===============================================
    // GLOBAL VARIABLES: CIRCUIT MODEL SIMULATION
    //===============================================
    let X,Y              // system size
    let ground,groundNew // 2D array: main layer of cells in cellular automaton
    let subway,subwayNew // 2D array: underground layer of cells
    //===============================================
    // GLOBAL VARIABLES: GAMEPLAY AND EYECANDY
    //===============================================
    const WALKABLE=0,UNWALKABLE=1,LAMP=2,SOURCE=3,PEACH=4,PEACH_DYING=8,BOWSER=16,BOWSER_DYING=32
    const PLAYING=0,WIN=1,LOSE=-1
    let timeStepInMilliseconds=100
    let level=0,levelName,tcur   // current level,  current simulation time (in game ticks)
    let extras          // 2D array: gameplay-related info
    let cellsize        // cell size in pixels
    let xCursor,yCursor // cursor position (actually player)
    let marioOrientation=3;
    let xShaking=0,yShaking=0
    let winlose=PLAYING 
    let timeOfLastFrame=0


    function isHot(i)  {return i==5||i==6||i==7}
    function isCold(i) {return i==1||i==2||i==3}
    
    //===============================================
    // evolve(): EVOLVE CELLULAR AUTOMATON
    // Reads global variables: X,Y,ground,subway
    // Writes contents of:     ground,subway
    //===============================================
    function evolve() {
      for (let y=0; y<Y; ++y) for (let x=0; x<X; ++x) {
        
        if (extras[x+X*y]==SOURCE) {
          if (ground[x+X*y]>4) groundNew[x+X*y]=7
          else if (ground[x+X*y]<4) groundNew[x+X*y]=1  // WE DO NEED THIS
          
        }
        else {


          //======== Consider ground-level state
          let C=ground[x+X*y]
          //======== Get states of East and West neighbors
          let E=ground[(x+1)+X*y]
          let W=ground[(x-1)+X*y]
          //======== If current location has a subway, then ground level has NO N and S neighbors
          let N,S;
          if (subway[x+X*y]) {N=0; S=0}
          else {
            //======== If North neighbor has a subway, use the subway value; otherwise use ground value
            N=subway[x+X*(y-1)]; if(N==0) N=ground[x+X*(y-1)]
            S=subway[x+X*(y+1)]; if(S==0) S=ground[x+X*(y+1)]
          }

          if (extras[(x+1)+X*y]==PEACH) E=0 // SPECIAL RULE: PEACH BLOCKS LAVA
          if (extras[(x-1)+X*y]==PEACH) W=0 // SPECIAL RULE: PEACH BLOCKS LAVA
          if (extras[x+X*(y-1)]==PEACH) N=0 // SPECIAL RULE: PEACH BLOCKS LAVA
          if (extras[x+X*(y+1)]==PEACH) S=0 // SPECIAL RULE: PEACH BLOCKS LAVA
          
          //======== Update ground-level state 
          if (W==4)      {C=1}  // copy state from gate at west
          else if (W==8) {C=7}  // copy state from gate at west
          else {
            switch(C) {
              case 7: C=6; break // hot burning -> hot burned
              case 6: C=5; break // hot burned -> hot dormant
              case 1: C=2; break // cold burning -> cold burned
              case 2: C=3; break // cold burning -> cold dormant
              case 3: case 5: // cold dormant or hot dormant
                if ((E&7)==1 || (W&7)==1 || (N&7)==1 || (S&7)==1) C=1
                if ((E&7)==7 || (W&7)==7 || (N&7)==7 || (S&7)==7) C=7
                break
              case 4: case 8: // current ground is a NOR GATE
                if      (  (W&7)>4 || (N&7)>4 || (S&7)>4 )             C=4
                else if (  isCold(W&7) || isCold(N&7) || isCold(S&7) ) C=8
                else C=C 
            }
          }
          groundNew[x+X*y] = C
          //======== Update subway-level state (based on N and S only)
          C=subway[x+X*y]
          switch(C) {
            case 0: break      // not a crossing
            case 7: C=6; break // hot burning -> hot burned
            case 6: C=5; break // hot burned -> hot dormant
            case 1: C=2; break // cold burning -> cold burned
            case 2: C=3; break // cold burning -> cold dormant
            case 3: case 5: // cold dormant or hot dormant
              N=ground[x+X*(y-1)]
              S=ground[x+X*(y+1)]
              if ((N&7)==1 || (S&7)==1) C=1
              if ((N&7)==7 || (S&7)==7) C=7
              break
          }
          subwayNew[x+X*y] = C
        } 

      }
      for (let y=0; y<Y; ++y) for (let x=0; x<X; ++x) ground[x+X*y]=groundNew[x+X*y] // synchronous update
      for (let y=0; y<Y; ++y) for (let x=0; x<X; ++x) subway[x+X*y]=subwayNew[x+X*y] // synchronous update


    }

    //=================================================
    // GRAPHICS
    //=================================================
    // function rgb(r,g,b) {return ["rgb(",r,",",g,",",b,")"].join("");}
    // function xyBoard(x,y) {return[Math.floor(x/cellsize),Math.floor(y/cellsize)]}
    // function xyScreen(x,y) {return[x*cellsize,y*cellsize]} // top left corner
    const clamp=(x,a,b) => Math.min(Math.max(x,a),b)
    class Animation {
      constructor(frames)       {this.frames = frames } // list of images
      draw(x, y, iFrame)        {ctx.drawImage(this.frames[iFrame], x, y)  }
      draw(x, y, w, h, iFrame)  {ctx.drawImage(this.frames[iFrame], x, y, w, h)  }
    }

    function render() {
      const h=cellsize // alias for convenience
      //======== DRAW BACKGROUND AND GAME AREA
      ctx.clearRect(0, 0, canvas.width, canvas.height)
      ctx.fillStyle='#000';   ctx.fillRect(0,0, X*h, Y*h)
      //======== INDICATE ACCESSIBLE CELLS BY GREEN BACKGROUND
      for (let y=0; y<Y; ++y) for (let x=0; x<X; ++x) if (extras[x+X*y]==WALKABLE) {
         ctx.drawImage(imgGrass, x*h, y*h, h, h)
      }
      //======== DRAW CIRCUIT
      ctx.lineWidth=2 //; ctx.font = '10px Arial'
      for (let y=0; y<Y; ++y) for (let x=0; x<X; ++x) {
        let i=x+X*y, c=ground[i]
        if (c==0) continue
        switch(c) {
          case 1: case 2: case 3: 
            ctx.drawImage(imgDirt, x*h, y*h, h, h)
            break
          case 5: case 6: case 7: 
            ctx.drawImage(imgLava, x*h, y*h, h, h)
            break
          case 4: // at least one input is HIGH, output is LOW
            ctx.drawImage(imgDirt, x*h, y*h, h, h)
            if (ground[(x-1)+X*y]>4) ctx.drawImage(imgLava, 0,0,32,64, x*h,y*h,h/2,h)
            if (ground[x+X*(y-1)]>4) ctx.drawImage(imgLava, 0,0,64,32, x*h,y*h,h,h/2)
            if (ground[x+X*(y+1)]>4) ctx.drawImage(imgLava, 0,32,64,32, x*h,y*h+h/2,h,h/2)
            animCrying.draw(x*h,y*h,h,h, (Math.floor(tcur/10)%2))
            break
          case 8:  // both inputs are LOW, output is HIGH (?)
            ctx.drawImage(imgDirt, x*h, y*h, h, h)
            animHappy.draw(x*h,y*h,h,h, (Math.floor(tcur/12)%2))
            break
        }
        if (subway[x+X*y]>0) { // draw crossing as "bridge"
          ctx.fillStyle='#964B00' // brown wood bridge
          ctx.fillRect(x*h,y*h, h,4)
          ctx.fillRect(x*h,y*h+h-4, h,4)
        }
      }
      //======== DRAW SPECIAL OBJECTS (LAMPS, SOURCES, PEACHES, BOWSER)
      let size,xcen,ycen
      for (let y=0; y<Y; ++y) for (let x=0; x<X; ++x) {
        switch (extras[x+X*y]) {
          case LAMP:
            if (ground[x+X*y]>4) {
              if ((Math.floor(tcur/10)%2)) ctx.drawImage(imgStarOn, x*h-24, y*h-24, h+48, h+48)
              else                         ctx.drawImage(imgStarOn, x*h-20, y*h-20, h+40, h+40)
              // should remake this into an Animation
            }
            else ctx.drawImage(imgStarOff, x*h-20, y*h-20, h+40, h+40)
            break
          case SOURCE:
            if (ground[x+X*y]<4)      ctx.drawImage(imgSourceOff, x*h, y*h, h, h)
            else if (ground[x+X*y]>4) ctx.drawImage(imgSourceOn, x*h, y*h, h, h)
            break
          case PEACH:
            size=h*1.1,xcen=(x+.5)*h,ycen=(y+.5)*h
            animPeach.draw(xcen-size/2, ycen-size/2, size,size, (Math.floor(tcur/140)%2))          
            break
          case PEACH_DYING:
            size=h*1.1,xcen=(x+.5)*h + xShaking,ycen=(y+.5)*h + yShaking // reuse  these variables
            ctx.save(); // Save current canvas state
            ctx.translate(xcen,ycen); // Translate to the center of the image
            ctx.rotate(tcur*.1); // Rotate  by radians
            animPeach.draw(-size/2, -size/2, size, size, 0)
            ctx.restore(); // Restore the canvas to its original state
            if (tcur<100) {xShaking+=Math.cos(tcur*.6)*2; yShaking=Math.sin(tcur*.3)*10 }
            else {xShaking=0; yShaking += (tcur-20)*.03}
            break
          case BOWSER:
            size=h*1.5,xcen=(x+.5)*h,ycen=(y+.5)*h
            ctx.drawImage(imgBowser, xcen-size/2, ycen-size/2, size,size)
            break
          case BOWSER_DYING:
            size=h*1.5,xcen=(x+.5)*h+xShaking,ycen=(y+.5)*h+yShaking
            ctx.drawImage(imgBowser, xcen-size/2, ycen-size/2, size,size)
            if (tcur<100) {xShaking+=Math.cos(tcur*.6)*2; yShaking=Math.sin(tcur*.3)*10 }
            else {xShaking=0; yShaking+=(tcur-20)*.03}          
            break
        }
      }
      //======== DRAW MARIO
      tcur += 1
      let asp = imgMarioE.height/imgMarioE.width;
      switch (marioOrientation) {
        case 0: ctx.drawImage(imgMarioE, xCursor*h, yCursor*h, h/asp, h); break
        case 1: ctx.drawImage(imgMarioW, xCursor*h, yCursor*h, h/asp, h); break
        case 2: ctx.drawImage(imgMarioN, xCursor*h, yCursor*h, h/asp, h); break
        case 3: ctx.drawImage(imgMarioS, xCursor*h, yCursor*h, h/asp, h); break
      }
      //======== DRAW FRAME AROUND GAME AREA
      ctx.strokeStyle='#FFF'; ctx.strokeRect(0,0, X*h, Y*h)
    }

    function animate(timeCurrent) {
      //======== CHECK FOR WIN/LOSS
      if (winlose==PLAYING) {   
        
        for (let y=0; y<Y; ++y) for (let x=0; x<X; ++x) {
          if (extras[x+X*y]==BOWSER && ground[x+X*y]>4) {
            extras[x+X*y]=BOWSER_DYING 
            winlose=WIN; 
            // Bowser is burned (there's only one); or could check for killing multiple Bowsers
            break
          }
        }
        for (let y=0; y<Y; ++y) for (let x=0; x<X; ++x) {
          if (extras[x+X*y]==PEACH && ground[x+X*y]>4) {
            extras[x+X*y]=PEACH_DYING  // yeah man you really screwed this up
            winlose=LOSE
            break
          }
        }
        if (winlose==WIN) win()
        if (winlose==LOSE) lose()
      }      

      requestAnimationFrame(animate)
      render()

      let elapsed = Date.now() - timeOfLastFrame
      if (elapsed <= timeStepInMilliseconds) return
      timeOfLastFrame = Date.now()

      evolve()
    }
    //=================================================
    // EVENT HANDLERS
    //=================================================
    async function tryWalk(xnew,ynew) {
      audioTock = await audioTock
      audioBuzz = await audioBuzz
      if (xnew<0||xnew>=X||ynew<0||ynew>=Y) {audioBuzz.play(); return 0}
      if (extras[xnew+X*ynew]==SOURCE) { // Mario bumps a P Switch, toggling it
        audioTock.play()
        if      (ground[xnew+X*ynew]<4) ground[xnew+X*ynew]=7
        else if (ground[xnew+X*ynew]>4) ground[xnew+X*ynew]=1
        return 0
      }
      if (ground[xnew+X*ynew]==4) { // Mario bumps a toad, toggling it?
        audioTock.play(); ground[xnew+X*ynew]=8; return 0
      }
      if (ground[xnew+X*ynew]==8) { // Mario bumps a toad, toggling it?
        audioTock.play(); ground[xnew+X*ynew]=4; return 0
      }
      if (extras[xnew+X*ynew]!=WALKABLE) {audioBuzz.play(); return 0}
      xCursor=xnew; yCursor=ynew; audioTock.play(); return 1
    }
    async function win() {
      tcur=0
      audioWin0 = await audioWin0
      audioWin1 = await audioWin1
      audioWin0.play()
      setTimeout( ()=>{audioWin1.play()}, 1000)
    }
    async function lose() {
      tcur=0
      audioLose = await audioLose
      audioLose.play()
      //alert("ARGH YOU BURNED THE PEACH!")
    }
    function walkW()      {marioOrientation=1; tryWalk(xCursor-1,yCursor)}
    function walkE()      {marioOrientation=0; tryWalk(xCursor+1,yCursor)}
    function walkN()      {marioOrientation=2; tryWalk(xCursor,yCursor-1)}
    function walkS()      {marioOrientation=3; tryWalk(xCursor,yCursor+1)}
    function placeLava()  {ground[xCursor+X*yCursor]=7; audioTock.play()}
    function placeDirt()  {ground[xCursor+X*yCursor]=1; audioTock.play()}
    function placeGrass() {ground[xCursor+X*yCursor]=0; audioTock.play()}
    function placeToad()  {ground[xCursor+X*yCursor]=4; audioTock.play()}
    function placeSubway(){ // actually TOGGLE SUBWAY ON/OFF
      if(subway[xCursor+X*yCursor]) subway[xCursor+X*yCursor]=0;
      else subway[xCursor+X*yCursor]=3
    }
    function goSlow()  {timeStepInMilliseconds=100}
    function goFast()  {timeStepInMilliseconds=1}
    function enterCheatMode() {
      for(let y=0;y<Y;++y)for(let x=0;x<X;++x)
        if (extras[x+X*y]==UNWALKABLE) extras[x+X*y]=WALKABLE
      btnLava.disabled = false
      btnDirt.disabled = false
      btnToad.disabled = false
      btnCross.disabled = false
      btnGrass.disabled = false
    }
    
    async function keydown(e) {
      if (e.ctrlKey||e.altKey) return // don't trap browser shortcuts involving Ctrl or Alt
      let processed=true
      switch (e.key) {
        case '[': setLevel(level-1); break
        case ']': setLevel(level+1); break
        case 'e': walkN(); break
        case 's': walkW(); break
        case 'd': walkS(); break
        case 'f': walkE(); break // move cursor// case 'ArrowRight':
        case ' ': 
          if      (ground[xCursor+X*yCursor]==0) ground[xCursor+X*yCursor]=1 // cold active
          else if (ground[xCursor+X*yCursor]<4)  ground[xCursor+X*yCursor]=7 // hot active
          else                           ground[xCursor+X*yCursor]=0
          audioTock.play()
          break
        case 'h': placeLava(); break    // add hot burning
        case 'j': placeDirt(); break    // add cold burning
        case 'k': placeSubway(); break // toggle crossing
        case 'l': placeToad(); break    // add NOR gate (Toad)
        case ';': placeGrass(); break // erase current ground  //case 'Backspace': case 'Delete':                 
        case 'C': enterCheatMode(); break
        case 'R': await resetGame(); break    // reset level
        default: processed=false
      }
      //if (e.shiftKey==true) ground[xCursor+X*yCursor] = 3 // add cold dormant
      if (processed) {e.preventDefault(); e.stopPropagation(); }
    }


    //===============================================
    // loadLevel()
    // Writes global X,Y,ground,groundNew,subway,subwayNew
    // printMap()
    // Reads global X,Y,ground
    //===============================================
    async function loadLevel(levelMap) {
      levelMap = await levelMap
      // console.log(levelMap)

      let match
      const regex1 = /<timestep>(.*?)<\/timestep>\s+/gs
      match = regex1.exec(levelMap)
      if (match) {
        timeStepInMilliseconds=Number(match[1])
        levelMap = levelMap.replace(regex1, "")
      }
     
      const regex2 = /<<<name>>>(.*?)<\/name>\s+/gs 
      match = regex2.exec(levelMap)
      if (match) {
        levelName=match[1]
        levelMap = levelMap.replace(regex2, "")
      }

      let preconverge=1 // default is YES
      const regex3 = /<preconverge>(.*?)<\/preconverge>\s+/gs
      match = regex3.exec(levelMap)
      if (match) {
        preconverge=Number(match[1])
        levelMap = levelMap.replace(regex3, "")
      }

      let sandbox=0 // default is NO, NOT A SANDBOX
      const regex4 = /<sandbox>(.*?)<\/sandbox>\s+/gs
      match = regex4.exec(levelMap)
      if (match) {
        sandbox=Number(match[1])
        levelMap = levelMap.replace(regex4, "")
      }
      btnLava.disabled = !sandbox
      btnDirt.disabled = !sandbox
      btnToad.disabled = !sandbox
      btnCross.disabled = !sandbox
      btnGrass.disabled = !sandbox
     
      let rows = /<levelmap>\s+(.*?)<\/levelmap>/gs . exec(levelMap) [1]
      rows = rows.split(/[\r\n]/).filter(i=>i) 
      
      //-------- DETERMINE MAP SIZE AND ALLOCATE ARRAYS
      X = Math.max(...rows.map(s=>s.length))        // length of longest line
      Y = rows.length
      ground   =new Int8Array(X*Y)
      groundNew=new Int8Array(X*Y)
      subway   =new Int8Array(X*Y)
      subwayNew=new Int8Array(X*Y)
      //-------- POPULATE ARRAYS
      for (let y=0; y<Y; ++y) for (let x=0; x<X; ++x) {
        ground[x+X*y]=0   // START WITH BARE GROUND    
        subway[x+X*y]=0   // START WITH NO CROSSINGS
      }
      for (let y=0; y<rows.length; ++y) {
        for (let x=0; x<rows[y].length && x<X; ++x) {
          switch (rows[y][x]) {
            case ' ':case'.': ground[x+X*y]=0; break   // grass, void, or bare ground
            case '#': ground[x+X*y]=3; break           // dirt
            case '1': case '2': case '3': case '5': case '6': case '7': ground[x+X*y]=rows[y][x]-'0'; break
            case 'n': ground[x+X*y]=4; break // NOR gate, initially off?
            case 'N': ground[x+X*y]=8; break // NOR gate, initially on?
            case '+': ground[x+X*y]=3; subway[x+X*y]=3; break // crossing
            default: ground[x+X*y]=0
          }
        }
      }

      //-------- GAMEPLAY: ALSO LOAD "extras"
      extras=new Int8Array(X*Y) // for mario moving
      for (let y=0; y<Y; ++y) for (let x=0; x<X; ++x) extras[x+X*y]=UNWALKABLE
      for (let y=0; y<rows.length; ++y) {
        for (let x=0; x<rows[y].length && x<X; ++x) {
          switch (rows[y][x]) {
            case 'L': extras[x+X*y]=LAMP; ground[x+X*y]=3; break // Lamp
            case 's': extras[x+X*y]=SOURCE; ground[x+X*y]=3; break // Source (P Switch) off
            case 'S': extras[x+X*y]=SOURCE; ground[x+X*y]=5; break // Source (P Switch) on
            case 'P': extras[x+X*y]=PEACH; ground[x+X*y]=3; break // Peach starts unburned
            case 'B': extras[x+X*y]=BOWSER; ground[x+X*y]=3; break // Bowser starts unburned
            case '.':case'M':extras[x+X*y]=WALKABLE; break
            default:  extras[x+X*y]=UNWALKABLE; break
          }
        }
      }
      //-------- GAMEPLAY: PRE-CONVERGE TO STEADY STATE PREVENT PREMATURE WIN
      if (preconverge) for (let iter=0; iter<1000; ++iter) evolve()
      //-------- GAMEPLAY: IDENTIFY START POSITION
      for (let y=0; y<Y; ++y) for (let x=0; x<X; ++x) if (rows[y][x]=='M') {xCursor=x; yCursor=y}   
      xShaking=0;yShaking=0


      // for (let y=0; y<Y; ++y) {
      //   let s=''
      //   for (let x=0; x<X; ++x) {
      //     s+=ground[x+X*y]
      //   }
      //   console.log(s)
      // }
    }
    function setScaling() {
      winWid=window.innerWidth||document.documentElement.clientWidth||document.body.clientWidth
      winHei=window.innerHeight||document.documentElement.clientHeight||document.body.clientHeight
      let availWidth =clamp(winWid, 300, 1600) // set canvas width according to window width; warning: btnSize=48
      let availHeight=clamp(winHei, 300, 800) // may reduce this
      cellsize=Math.min(Math.floor(availWidth/X),Math.floor((availHeight)/Y)) // for graphics
      canvas.width=X*cellsize
      canvas.height=Y*cellsize
    }
    async function resetGame() {
      tcur=0; xCursor=0; yCursor=0; winlose=PLAYING
      await loadLevel(levelMaps[level])
      setScaling()
      title.innerHTML = levelName
    }
    async function setLevel(newLevel) {
      if (newLevel<0||newLevel>=levelMaps.length) return // if new level number is illegal, don't load it
      level = newLevel
      btnPrev.disabled = (level==0)             // if current level is 0, disable "Previous Level" button
      btnNext.disabled = (level==levelMaps.length-1) // if we are on last level, disable "Next Level" button
      await resetGame()
    }
    async function prevLevel() {await setLevel(level-1)}
    async function nextLevel() {await setLevel(level+1)}

    function openHelp() {
      winWid=window.innerWidth||document.documentElement.clientWidth||document.body.clientWidth
      winHei=window.innerHeight||document.documentElement.clientHeight||document.body.clientHeight
      const wid=winWid - 32
      const hei=winHei - 32
      const windowFeatures = `popup=true,width=${wid},height=${hei}`
      console.log(windowFeatures)
      let newWin = window.open('toadburnhelp.html', 'blankWindow', windowFeatures)
      if (newWin) {
        // newWin.document.write('<h1>Hello from the new window!</h1>')
      }
    }
    //===============================================
    // MAIN MODULE CODE
    //===============================================
    let winWid,winHei
    document.body.addEventListener('dblclick', function(e) { e.preventDefault() })
    const ctx=canvas.getContext('2d')
    setScaling()
    document.body.insertBefore(canvas, document.body.childNodes[0])
    window.addEventListener('resize', setScaling)

    //===============================================
    // Wait for ESSENTIAL resources to load
    //===============================================
    // const resources = await Promise.all([...imagePromises,...audioPromises])
    // let [imgMario,imgBowser,imgGrass,imgDirt,imgLava,imgCrying1,imgCrying2,imgHappy1,imgHappy2,
    //     imgStarOn,imgStarOff,
    //     audioTock,audioBuzz,audioWin,audioWin0] = resources
    let audioTock = loadAudio('tock.mp3')
    let audioBuzz = loadAudio('buzz.mp3')
    let audioWin0 = loadAudio('win1.mp3')
    let audioWin1 = loadAudio('win2.mp3')
    let audioLose = loadAudio('lose.mp3')

    let imgMarioE = await loadImage('marioE.webp')
    let imgMarioW = await loadImage('marioW.webp')
    let imgMarioN = await loadImage('marioN.webp')
    let imgMarioS = await loadImage('marioS.webp')

    // let imgMario = await loadImage('mario.png')
    let animPeach = new Animation([await loadImage('peach1.webp'),await loadImage('peach2.webp')])
    let imgBowser = await loadImage('bowser.webp')
    let imgGrass = await loadImage('grass.webp')
    let imgDirt = await loadImage('dirt.webp') // dirt
    let imgLava = await loadImage('lava.webp')
    // let imgCrying1 = await loadImage('crying1.webp')
    // let imgCrying2 = await loadImage('crying2.webp')
    let animCrying = new Animation([await loadImage('crying1.webp'),await loadImage('crying2.webp')])

    let imgHappy1 = await loadImage('happy1.webp')
    let imgHappy2 = await loadImage('happy2.webp')
    let animHappy = new Animation([imgHappy1,imgHappy2])
    let imgStarOn = await loadImage('staron.webp')
    let imgStarOff = await loadImage('staroff.webp')
    let imgSourceOff = await loadImage('sourceoff.webp')
    let imgSourceOn = await loadImage('sourceon.webp')

    let levelMaps = await loadString('toadburnmaps.txt') // clear browser cache if this file is edited
    // TBD: do properly using Promise
    levelMaps = [...levelMaps.matchAll(  /<levelmap>.*?<\/levelmap>/gs )].map(i=>i[0])
    await setLevel(0)
    splashScreen.style.visibility = "hidden"
    controls.style.visibility = "visible"
    document.body.addEventListener('keydown', keydown, false)
    btnReset.addEventListener('click', resetGame)
    btnPrev.addEventListener('click', prevLevel)
    btnNext.addEventListener('click', nextLevel)
    btnLeft.addEventListener('click', walkW)
    btnRight.addEventListener('click', walkE)
    btnUp.addEventListener('click', walkN)
    btnDown.addEventListener('click', walkS)
    // btnLeft.addEventListener('touchstart', walkW)
    // btnRight.addEventListener('touchstart', walkE)
    // btnUp.addEventListener('touchstart', walkN)
    // btnDown.addEventListener('touchstart', walkS)
    btnLava.addEventListener('click', placeLava)
    btnDirt.addEventListener('click', placeDirt)
    btnCross.addEventListener('click', placeSubway)
    btnGrass.addEventListener('click', placeGrass)
    btnToad.addEventListener('click', placeToad)
    btnSlow.addEventListener('click', goSlow)
    btnFast.addEventListener('click', goFast)
    btnCheat.addEventListener('click', enterCheatMode)

    btnHelp.addEventListener('click', openHelp)
    
    requestAnimationFrame(animate)
  </script>
</body>
</html> 