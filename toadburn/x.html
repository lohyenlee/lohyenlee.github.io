<!DOCTYPE html>
<html>
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="icon" href="favicon.ico" type="image/x-icon">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link rel="preload" href="peach1.webp" as="image">
  <link rel="preload" href="peach2.webp" as="image">
  <link rel="preload" href="happy1.webp" as="image">
  <link rel="preload" href="happy2.webp" as="image">
  <link rel="preload" href="bowser.webp" as="image">
  <link rel="preload" href="grass.webp" as="image">
  <link rel="preload" href="dirt.webp" as="image">
  <link rel="preload" href="lava.webp" as="image">
  <!-- <link rel="preload" href="crying1.webp" as="image"> -->
  <!-- <link rel="preload" href="crying2.webp" as="image"> -->
  <!-- <link rel="preload" href="staron.webp" as="image"> -->
  <!-- <link rel="preload" href="staroff.webp" as="image"> -->
  <style>
    /* @font-face {
      font-family: 'Titillium Web';
      font-style: normal;
      font-weight: 700;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/titilliumweb/v19/NaPDcZTIAOhVxoMyOr9n_E7ffHjDGItzYw.woff2) format('woff2');
      unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+0304, U+0308, U+0329, U+2000-206F, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
    } */
    @font-face {
      font-family: 'gameFont';
      src: url('Retro Gaming.ttf') format('truetype'); /* Specify the path to your .ttf file */
      font-weight: normal; /* Define the weight (e.g., normal, bold) */
      font-style: normal;  /* Define the style (e.g., normal, italic) */
    }
    :root {--btnsize:8vmin;}
    html,body { 
      overflow: hidden;  /* prevent scrollbars */
      background-color:#333; padding:0; margin:0; width:100%; height:100%; font-family:'gameFont',sans-serif;
    }
    #splashScreen {
      width: 100%; height:100%; text-align: center; color:white;
      border:1px solid black;
      background: linear-gradient(130deg, #262626, #ff7e00, #fff200);
      background-size: 200% 200%;
      animation: Animation 4s ease infinite;
    }   
    @keyframes Animation { 
      0%{background-position:10% 0%}
      50%{background-position:91% 100%}
      100%{background-position:10% 0%}
    }
    #canvas {position:absolute; z-index:1;}
    #helpDivContainer {
      margin: 32px;
      padddng: 32px;
    }
    #helpDiv {
      display: none;  /* overflow:scroll; */
      z-index:4;position:absolute; 
      /* left:10vw;width:80vw; top:20vh;height:60vh;  */
      /* left:10vw;width:80vw; top:20vh;height:60vh;  */
      /* left: 70%; top: 0%; transform: translate(-70%, 0%); */
      right: 0; bottom:0;
      height:fit-content;
      width:80%; 
      padding: 1rem 2rem 1rem 6rem; 
      box-shadow: 0px 4 px 8px 0px #333, 0px 8px 16px 8px #000;
      background-color:#666; border:double 4px black; border-radius: 20px; 
      color:white; font-family:'gameFont',sans-serif; font-size: 1.5rem;
      background-image:url('peach1.webp');background-size:6rem;background-repeat:no-repeat;background-position:0rem;
    }
    #helpDiv h2 {
        background-image:url('happy1.webp');background-size:contain;background-repeat: no-repeat;background-position:0px;
        padding:0 0 0 48px; color:#fff;
    }
    #title {position:absolute; z-index:2; top:0; left:0; width:100%;padding:0;text-align:center; font-size:3vmin; color:white; white-space:pre;}
    #controls {position:absolute; z-index:3; bottom:0; left:0; width:100%; display:none;}
    button {cursor:pointer;
            float:left;margin:0;padding:0;text-align:center; border-radius:8px; font-family:'gameFont',sans-serif; 
            font-size: 4vmin;
            background-color:#666; color:white;
            background-repeat: no-repeat;}
    button:disabled {opacity:25%;}
    .btn1 { width:var(--btnsize); height:var(--btnsize); background-size:cover; 
            text-shadow: 2px 2px 3px black;
          } /* square button */
    .btn2 { width:calc(10vmin); height:var(--btnsize);margin:1px; padding:0; font-size: 2vmin;}
    .separator { height:16px; clear:left; }
    .indepth {font-size:1rem;color:#DDD;}
  </style>
</head>
<body id="body">
  <div id="splashScreen">
    <div style="text-align: center; vertical-align:center; margin:2rem 0rem; font-size:5rem;"> T O A D   B U R N </div>
    <div style="text-align: center; margin:3rem 0rem; font-size:2rem;"> By Yen Lee Loh and Isaac Hutchison </div>
    <div style="text-align: center; font-size:2rem;"> Loading... </div>
  </div>

  <div id="helpDivContainer">
  <div id="helpDiv"></div>
  </div>
  

  <div id="title"></div> 
  <canvas id="canvas">Your browser does not support the HTML5 canvas tag.</canvas>
  <!-- <div id="controls"> -->
  <div id="controls" style="position:absolute; bottom:0; left:0; width:100%;">
    <div style="position: absolute; left:0;bottom:0; width:calc(3*var(--btnsize));" id="movementKeypad">
      <!-- <div class="separator"></div> -->
      <button               class="btn1" style="visibility: hidden;">  </button>
      <!-- <button id="btnHelp"  class="btn1" style="background-image:url(question.webp);"></button> -->
      <button id="btnUp"    class="btn1" style="background-image:url(arrowU.svg);"> E </button>
      <button               class="btn1" style="visibility: hidden;">  </button>
      <button id="btnLeft"  class="btn1" style="background-image:url(arrowL.svg);"> S </button>
      <button id="btnDown"  class="btn1" style="background-image:url(arrowD.svg);"> D </button>
      <button id="btnRight" class="btn1" style="background-image:url(arrowR.svg);"> F </button>
    </div>
    <div style="float:right; width:calc(5*var(--btnsize));" id="actionButtons">
      <button id="btnLava"  class="btn1" style="background-image:url(lava.webp);" disabled="disabled"> H </button>
      <button id="btnDirt"  class="btn1" style="background-image:url(dirt.webp);" disabled="disabled"> J </button>
      <button id="btnCross" class="btn1" style="background-image:url(crossing.webp);" disabled="disabled"> K </button>
      <button id="btnToad"  class="btn1" style="background-image:url(happy1.webp); color:#FFF;" disabled="disabled"> L </button>
      <button id="btnGrass" class="btn1" style="background-image:url(grass.webp);" disabled="disabled"> ; </button>
    </div>
    <div style="display:flex; vertical-align:bottom; float:right; margin:0ex 5ex 0ex 5ex;">
      <button id="btnPrev"  class="btn2" title="Key: [">       PREV </button>
      <button id="btnReset" class="btn2" title="Key: Shift-R"> RESET </button>
      <button id="btnNext"  class="btn2" title="Key: [">       NEXT  </button>
      <button id="btnSlow"  class="btn2">SLOW</button>
      <button id="btnFast"  class="btn2">FAST</button>
      <button id="btnCheat" class="btn2" title="Key: Shift-C"> CHEAT</button>
    </div>
  </div>
  <script type="module">
    //=======================================================
    // IMAGE, AUDIO, AND STRING LOADERS
    //=======================================================
    function loadImage(url) { 
      // console.log('Requesting', url)
      return new Promise((resolve,reject) => { 
        let image = new Image()
        image.onload  = ()=>resolve(image)
        // image.onload  = ()=>{console.log("Loaded"         ,url);resolve(image)}
        image.onerror = ()=>{console.log("Failed to load ",url);reject()      }
        image.src     = url
      })
    }
    function loadAudio(url) {
      // console.log('Requesting', url)
      return new Promise((resolve,reject) => { 
        let audio = new Audio(url)
        audio.oncanplaythrough = ()=>resolve(audio)
        //audio.oncanplaythrough = ()=>{console.log("Loaded"         ,url);resolve(audio)}
        audio.onerror          = ()=>{console.log("Failed to load ",url);reject()}
        // audio.addEventListener("canplaythrough", ()=>{console.log("Loaded", url); resolve(audio)})
      })
    }
    function loadString(url) {
      // console.log('Requesting', url)
      return fetch(url).then(r=>r.text()) 
    }
    function playAudio(audio) {  
      audio.play().catch(error => console.log('audio.play() was blocked'))
    }
    //===============================================
    // GLOBAL VARIABLES: CIRCUIT MODEL SIMULATION
    //===============================================
    let X,Y              // system size
    let ground,groundNew // 2D array: main layer of cells in cellular automaton
    let subway,subwayNew // 2D array: underground layer of cells
    //===============================================
    // GLOBAL VARIABLES: GAMEPLAY AND EYECANDY
    //===============================================
    const WALKABLE=0,UNWALKABLE=1,LAMP=2,SOURCE=3,PEACH=4,PEACH_DYING=8,BOWSER=16,BOWSER_DYING=32,QUESTION=127
    const PLAYING=0,WIN=1,LOSE=-1
    let timeStepInMilliseconds=100
    let level=0,levelName,tcur   // current level,  current simulation time (in game ticks)
    let extras          // 2D array: gameplay-related info
    let cellsize        // cell size in pixels
    let xCursor,yCursor // cursor position (actually player)
    let marioOrientation=3;
    let xShaking=0,yShaking=0
    let winlose=PLAYING 
    let timeOfLastFrame=0
    let helpText=""


    function isHot(i)  {return i==5||i==6||i==7}
    function isCold(i) {return i==1||i==2||i==3}
    
    //===============================================
    // evolve(): EVOLVE CELLULAR AUTOMATON
    // Reads global variables: X,Y,ground,subway
    // Writes contents of:     ground,subway
    //===============================================
    function evolve() {
      for (let y=0; y<Y; ++y) for (let x=0; x<X; ++x) {
        
        if (extras[x+X*y]==SOURCE) {
          if (ground[x+X*y]>4) groundNew[x+X*y]=7
          else if (ground[x+X*y]<4) groundNew[x+X*y]=1  // WE DO NEED THIS
          
        }
        else {


          //======== Consider ground-level state
          let C=ground[x+X*y]
          //======== Get states of East and West neighbors
          let E=ground[(x+1)+X*y]
          let W=ground[(x-1)+X*y]
          //======== If current location has a subway, then ground level has NO N and S neighbors
          let N,S;
          if (subway[x+X*y]) {N=0; S=0}
          else {
            //======== If North neighbor has a subway, use the subway value; otherwise use ground value
            N=subway[x+X*(y-1)]; if(N==0) N=ground[x+X*(y-1)]
            S=subway[x+X*(y+1)]; if(S==0) S=ground[x+X*(y+1)]
          }
          
          //======== Update ground-level state 
          if (W==4)      {C=1}  // copy state from gate at west
          else if (W==8) {C=7}  // copy state from gate at west
          else {
            switch(C) {
              case 7: C=6; break // hot burning -> hot burned
              case 6: C=5; break // hot burned -> hot dormant
              case 1: C=2; break // cold burning -> cold burned
              case 2: C=3; break // cold burning -> cold dormant
              case 3: case 5: // cold dormant or hot dormant
                if ((E&7)==1 || (W&7)==1 || (N&7)==1 || (S&7)==1) C=1
                if ((E&7)==7 || (W&7)==7 || (N&7)==7 || (S&7)==7) C=7
                break
              case 4: case 8: // current ground is a NOR GATE
                if      (  (W&7)>4 || (N&7)>4 || (S&7)>4 )             C=4
                else if (  isCold(W&7) || isCold(N&7) || isCold(S&7) ) C=8
                else C=C 
              case 0: // PEACH and BOWSER act as absorbers of HOT only
                if (extras[x+X*y]==PEACH||extras[x+X*y]==BOWSER) {
                  if ((E&7)==7 || (W&7)==7 || (N&7)==7 || (S&7)==7) C=5
                }
            }
          }
          groundNew[x+X*y] = C
          //======== Update subway-level state (based on N and S only)
          C=subway[x+X*y]
          switch(C) {
            case 0: break      // not a crossing
            case 7: C=6; break // hot burning -> hot burned
            case 6: C=5; break // hot burned -> hot dormant
            case 1: C=2; break // cold burning -> cold burned
            case 2: C=3; break // cold burning -> cold dormant
            case 3: case 5: // cold dormant or hot dormant
              N=ground[x+X*(y-1)]
              S=ground[x+X*(y+1)]
              if ((N&7)==1 || (S&7)==1) C=1
              if ((N&7)==7 || (S&7)==7) C=7
              break
          }
          subwayNew[x+X*y] = C
        } 

      }
      for (let y=0; y<Y; ++y) for (let x=0; x<X; ++x) ground[x+X*y]=groundNew[x+X*y] // synchronous update
      for (let y=0; y<Y; ++y) for (let x=0; x<X; ++x) subway[x+X*y]=subwayNew[x+X*y] // synchronous update


    }

    //=================================================
    // GRAPHICS
    //=================================================
    // function rgb(r,g,b) {return ["rgb(",r,",",g,",",b,")"].join("");}
    // function xyBoard(x,y) {return[Math.floor(x/cellsize),Math.floor(y/cellsize)]}
    // function xyScreen(x,y) {return[x*cellsize,y*cellsize]} // top left corner
    const clamp=(x,a,b) => Math.min(Math.max(x,a),b)
    class Animation {
      constructor(frames)       {this.frames = frames } // list of images
      draw(x, y, iFrame)        {ctx.drawImage(this.frames[iFrame], x, y)  }
      draw(x, y, w, h, iFrame)  {ctx.drawImage(this.frames[iFrame], x, y, w, h)  }
    }

    function render() {
      const h=cellsize // alias for convenience
      //======== DRAW BACKGROUND AND GAME AREA
      ctx.clearRect(0, 0, canvas.width, canvas.height)
      ctx.fillStyle='#000';   ctx.fillRect(0,0, X*h, Y*h)
      //======== INDICATE ACCESSIBLE CELLS BY GREEN BACKGROUND
      for (let y=0; y<Y; ++y) for (let x=0; x<X; ++x) if (extras[x+X*y]==WALKABLE) {
         ctx.drawImage(imgGrass, x*h, y*h, h, h)
      }
      //======== DRAW CIRCUIT
      ctx.lineWidth=2 //; ctx.font = '10px Arial'
      for (let y=0; y<Y; ++y) for (let x=0; x<X; ++x) {
        let i=x+X*y, c=ground[i]
        if (c==0) continue
        switch(c) {
          case 1: case 2: case 3: 
            ctx.drawImage(imgDirt, x*h, y*h, h, h)
            break
          case 5: case 6: case 7: 
            animLava.draw(x*h,y*h,h,h, (Math.floor((tcur+2*x+y)/16)%2))            
            break
          case 4: // at least one input is HIGH, output is LOW
            ctx.drawImage(imgDirt, x*h, y*h, h, h)
            if (ground[(x-1)+X*y]>4) ctx.drawImage(imgLava, 0,0,32,64, x*h,y*h,h/2,h)
            if (ground[x+X*(y-1)]>4) ctx.drawImage(imgLava, 0,0,64,32, x*h,y*h,h,h/2)
            if (ground[x+X*(y+1)]>4) ctx.drawImage(imgLava, 0,32,64,32, x*h,y*h+h/2,h,h/2)
            animCrying.draw(x*h,y*h,h,h, (Math.floor(tcur/10)%2))
            break
          case 8:  // both inputs are LOW, output is HIGH (?)
            ctx.drawImage(imgDirt, x*h, y*h, h, h)
            animHappy.draw(x*h,y*h,h,h, (Math.floor(tcur/12)%2))
            break
        }
        if (subway[x+X*y]>0) { // draw crossing as "bridge"
          ctx.fillStyle='#964B00' // brown wood bridge
          ctx.fillRect(x*h,y*h, h,4)
          ctx.fillRect(x*h,y*h+h-4, h,4)
        }
      }
      //======== DRAW SPECIAL OBJECTS (LAMPS, SOURCES, PEACHES, BOWSER)
      let size,xcen,ycen
      for (let y=0; y<Y; ++y) for (let x=0; x<X; ++x) {
        switch (extras[x+X*y]) {
          case QUESTION:
            ctx.drawImage(imgQuestion, x*h,y*h,h,h)
            break
          case LAMP:
            if (ground[x+X*y]>4) {
              if ((Math.floor(tcur/10)%2)) ctx.drawImage(imgStarOn, x*h-24, y*h-24, h+48, h+48)
              else                         ctx.drawImage(imgStarOn, x*h-20, y*h-20, h+40, h+40)
              // should remake this into an Animation
            }
            else ctx.drawImage(imgStarOff, x*h-20, y*h-20, h+40, h+40)
            break
          case SOURCE:
            if (ground[x+X*y]<4)      ctx.drawImage(imgSourceOff, x*h, y*h, h, h)
            else if (ground[x+X*y]>4) ctx.drawImage(imgSourceOn, x*h, y*h, h, h)
            break
          case PEACH:
            size=h*1.1,xcen=(x+.5)*h,ycen=(y+.5)*h
            ctx.drawImage(imgDirt,x*h,y*h,h,h)     
            animPeach.draw(xcen-size/2, ycen-size/2, size,size, (Math.floor(tcur/140)%2))          
            break
          case PEACH_DYING:
            animLava.draw(x*h,y*h,h,h, (Math.floor((tcur+2*x+y)/16)%2))            
            size=h*1.1,xcen=(x+.5)*h + xShaking,ycen=(y+.5)*h + yShaking // reuse  these variables
            ctx.save(); // Save current canvas state
            ctx.translate(xcen,ycen); // Translate to the center of the image
            ctx.rotate(tcur*.1); // Rotate  by radians
            animPeach.draw(-size/2, -size/2, size, size, 0)
            ctx.restore(); // Restore the canvas to its original state
            if (tcur<100) {xShaking+=Math.cos(tcur*.6)*2; yShaking=Math.sin(tcur*.3)*10 }
            else {xShaking=0; yShaking += (tcur-20)*.03}
            break
          case BOWSER:
            size=h*1.5,xcen=(x+.5)*h,ycen=(y+.5)*h
            ctx.drawImage(imgDirt,x*h,y*h,h,h)     
            ctx.drawImage(imgBowser, xcen-size/2, ycen-size/2, size,size)
            break
          case BOWSER_DYING:
            animLava.draw(x*h,y*h,h,h, (Math.floor((tcur+2*x+y)/16)%2))            
            size=h*1.5,xcen=(x+.5)*h+xShaking,ycen=(y+.5)*h+yShaking
            ctx.drawImage(imgBowser, xcen-size/2, ycen-size/2, size,size)
            if (tcur<100) {xShaking+=Math.cos(tcur*.6)*2; yShaking=Math.sin(tcur*.3)*10 }
            else {xShaking=0; yShaking+=(tcur-20)*.03}          
            break
        }
      }
      //======== DRAW MARIO
      tcur += 1
      let asp = imgMarioE.height/imgMarioE.width;
      xcen=(xCursor+.5)*h,ycen=(yCursor+.5)*h
      let sy=h*1.1, sx=sy/asp
      switch (marioOrientation) {
        case 0: ctx.drawImage(imgMarioE, xcen-sx/2, ycen-sy/2, sx, sy); break
        case 1: ctx.drawImage(imgMarioW, xcen-sx/2, ycen-sy/2, sx, sy); break
        case 2: ctx.drawImage(imgMarioN, xcen-sx/2, ycen-sy/2, sx, sy); break
        case 3: ctx.drawImage(imgMarioS, xcen-sx/2, ycen-sy/2, sx, sy); break
      }
      //======== DRAW FRAME AROUND GAME AREA
      ctx.strokeStyle='#FFF'; ctx.strokeRect(0,0, X*h, Y*h)
    }

    function animate(timeCurrent) {
      //======== CHECK FOR WIN/LOSS
      if (winlose==PLAYING) {   
        
        for (let y=0; y<Y; ++y) for (let x=0; x<X; ++x) {
          if (extras[x+X*y]==BOWSER && ground[x+X*y]>4) {
            extras[x+X*y]=BOWSER_DYING 
            winlose=WIN; 
            // Bowser is burned (there's only one); or could check for killing multiple Bowsers
            break
          }
        }
        for (let y=0; y<Y; ++y) for (let x=0; x<X; ++x) {
          if (extras[x+X*y]==PEACH && ground[x+X*y]>4) {
            extras[x+X*y]=PEACH_DYING  // yeah man you really screwed this up
            winlose=LOSE
            break
          }
        }
        if (winlose==WIN) win()
        if (winlose==LOSE) lose()
      }      

      requestAnimationFrame(animate)
      render()

      let elapsed = Date.now() - timeOfLastFrame
      if (elapsed <= timeStepInMilliseconds) return
      timeOfLastFrame = Date.now()

      evolve()
    }
    //=================================================
    // EVENT HANDLERS
    //=================================================
    async function tryWalk(xnew,ynew) {
      audioCoin = await audioCoin
      audioTock = await audioTock
      audioBuzz = await audioBuzz
      if (xnew<0||xnew>=X||ynew<0||ynew>=Y) {playAudio(audioBuzz); return 0}
      if (extras[xnew+X*ynew]==QUESTION) { // Mario bumps a Question block
        playAudio(audioCoin)
        await openHelp()
        helpDiv.focus() // hmm
        // console.log(helpDiv.style.visibility)
        return 0
      }      
      if (extras[xnew+X*ynew]==SOURCE) { // Mario bumps a P Switch, toggling it
        playAudio(audioTock)
        if      (ground[xnew+X*ynew]<4) ground[xnew+X*ynew]=7
        else if (ground[xnew+X*ynew]>4) ground[xnew+X*ynew]=1
        return 0
      }
      if (ground[xnew+X*ynew]==4) { // Mario bumps a toad, toggling it?
        playAudio(audioOof); ground[xnew+X*ynew]=8; return 0
      }
      if (ground[xnew+X*ynew]==8) { // Mario bumps a toad, toggling it?
        playAudio(audioOw); ground[xnew+X*ynew]=4; return 0
      }
      if (extras[xnew+X*ynew]!=WALKABLE) {playAudio(audioBuzz); return 0}
      xCursor=xnew; yCursor=ynew; playAudio(audioTock); return 1
    }
    async function win() {
      tcur=0
      audioWin0 = await audioWin0
      audioWin1 = await audioWin1
      playAudio(audioWin0)
      setTimeout( ()=>playAudio(audioWin1), 1000)
    }
    async function lose() {
      tcur=0
      audioLose = await audioLose
      playAudio(audioLose)
      //alert("ARGH YOU BURNED THE PEACH!")
    }
    function walkW()      {marioOrientation=1; tryWalk(xCursor-1,yCursor)}
    function walkE()      {marioOrientation=0; tryWalk(xCursor+1,yCursor)}
    function walkN()      {marioOrientation=2; tryWalk(xCursor,yCursor-1)}
    function walkS()      {marioOrientation=3; tryWalk(xCursor,yCursor+1)}
    function placeLava()  {ground[xCursor+X*yCursor]=7; playAudio(audioTock)}
    function placeDirt()  {ground[xCursor+X*yCursor]=1; playAudio(audioTock)}
    function placeGrass() {ground[xCursor+X*yCursor]=0; playAudio(audioTock)}
    function placeToad()  {ground[xCursor+X*yCursor]=4; playAudio(audioTock)}
    function placeSubway(){ // actually TOGGLE SUBWAY ON/OFF
      if(subway[xCursor+X*yCursor]) {
        subway[xCursor+X*yCursor]=0
        if (!ground[xCursor+X*yCursor]) ground[xCursor+X*yCursor]=3
      }
      else subway[xCursor+X*yCursor]=3
    }
    function goSlow()  {timeStepInMilliseconds=100}
    function goFast()  {timeStepInMilliseconds=1}
    function enterCheatMode() {
      for(let y=0;y<Y;++y)for(let x=0;x<X;++x)
        if (extras[x+X*y]==UNWALKABLE) extras[x+X*y]=WALKABLE
      btnLava.disabled = false
      btnDirt.disabled = false
      btnToad.disabled = false
      btnCross.disabled = false
      btnGrass.disabled = false
    }
    
    async function keydown(e) {
      if (helpDiv.style.display=="block") {helpDiv.style.display="none"; return}

      if (e.ctrlKey||e.altKey) return // don't trap browser shortcuts involving Ctrl or Alt
      let processed=true
      switch (e.key) {
        case '[': setLevel(level-1); break
        case ']': setLevel(level+1); break
        case 'e': walkN(); break
        case 's': walkW(); break
        case 'd': walkS(); break
        case 'f': walkE(); break // move cursor// case 'ArrowRight':
        case ' ': 
          if      (ground[xCursor+X*yCursor]==0) ground[xCursor+X*yCursor]=1 // cold active
          else if (ground[xCursor+X*yCursor]<4)  ground[xCursor+X*yCursor]=7 // hot active
          else                           ground[xCursor+X*yCursor]=0
          playAudio(audioTock)
          break
        case 'h': placeLava(); break    // add hot burning
        case 'j': placeDirt(); break    // add cold burning
        case 'k': placeSubway(); break // toggle crossing
        case 'l': placeToad(); break    // add NOR gate (Toad)
        case ';': placeGrass(); break // erase current ground  //case 'Backspace': case 'Delete':                 
        case 'C': enterCheatMode(); break
        case 'R': await resetGame(); break    // reset level
        default: processed=false
      }
      //if (e.shiftKey==true) ground[xCursor+X*yCursor] = 3 // add cold dormant
      if (processed) {e.preventDefault(); e.stopPropagation(); }
    }


    //===============================================
    // loadLevel()
    // Writes global X,Y,ground,groundNew,subway,subwayNew
    // printMap()
    // Reads global X,Y,ground
    //===============================================
    async function loadLevel(levelMap) {
      levelMap = await levelMap
      
      let match
      const regex1 = /<timestep>(.*?)<\/timestep>\s+/gs
      match = regex1.exec(levelMap)
      if (match) {
        timeStepInMilliseconds=Number(match[1])
        levelMap = levelMap.replace(regex1, "")
      }
     
      const regex2 = /<name>(.*?)<\/name>\s+/gs 
      match = regex2.exec(levelMap)
      if (match) {
        levelName=match[1]
        levelMap = levelMap.replace(regex2, "")
      }

      let preconverge=100 // default
      const regex3 = /<preconverge>(.*?)<\/preconverge>\s+/gs
      match = regex3.exec(levelMap)
      if (match) {
        preconverge=Number(match[1])
        levelMap = levelMap.replace(regex3, "")
      }

      let sandbox=0 // default is NO, NOT A SANDBOX
      const regex4 = /<sandbox>(.*?)<\/sandbox>\s+/gs
      match = regex4.exec(levelMap)
      if (match) {
        sandbox=Number(match[1])
        levelMap = levelMap.replace(regex4, "")
      }
      btnLava.disabled = !sandbox
      btnDirt.disabled = !sandbox
      btnToad.disabled = !sandbox
      btnCross.disabled = !sandbox
      btnGrass.disabled = !sandbox
 
      helpText="No help for this level!"
      const regex5 = /<help>\s+(.*?)<\/help>\s+/gs
      match = regex5.exec(levelMap)
      if (match) {
        helpText=match[1]
        levelMap = levelMap.replace(regex5, "")
      }

      let rows = /<levelmap>\s+(.*?)<\/levelmap>/gs . exec(levelMap) [1]
      rows = rows.split(/[\r\n]/).filter(i=>i)

      //-------- DETERMINE MAP SIZE AND ALLOCATE ARRAYS
      X = Math.max(...rows.map(s=>s.length))        // length of longest line
      Y = rows.length
      ground   =new Int8Array(X*Y)
      groundNew=new Int8Array(X*Y)
      subway   =new Int8Array(X*Y)
      subwayNew=new Int8Array(X*Y)
      //-------- POPULATE ARRAYS
      for (let y=0; y<Y; ++y) for (let x=0; x<X; ++x) {
        ground[x+X*y]=0   // START WITH BARE GROUND    
        subway[x+X*y]=0   // START WITH NO CROSSINGS
      }
      for (let y=0; y<rows.length; ++y) {
        for (let x=0; x<rows[y].length && x<X; ++x) {
          switch (rows[y][x]) {
            case ' ':case'.': ground[x+X*y]=0; break   // grass, void, or bare ground
            case '#': ground[x+X*y]=3; break           // dirt
            case '1': case '2': case '3': case '5': case '6': case '7': ground[x+X*y]=rows[y][x]-'0'; break
            case 'n': ground[x+X*y]=4; break // NOR gate, initially off?
            case 'N': ground[x+X*y]=8; break // NOR gate, initially on?
            case '+': ground[x+X*y]=3; subway[x+X*y]=3; break // crossing
            default: ground[x+X*y]=0
          }
        }
      }

      //-------- GAMEPLAY: ALSO LOAD "extras"
      extras=new Int8Array(X*Y) // for mario moving
      for (let y=0; y<Y; ++y) for (let x=0; x<X; ++x) extras[x+X*y]=UNWALKABLE
      for (let y=0; y<rows.length; ++y) {
        for (let x=0; x<rows[y].length && x<X; ++x) {
          switch (rows[y][x]) {
            case 'L': extras[x+X*y]=LAMP; ground[x+X*y]=3; break // Lamp
            case 's': extras[x+X*y]=SOURCE; ground[x+X*y]=3; break // Source (P Switch) off
            case 'S': extras[x+X*y]=SOURCE; ground[x+X*y]=5; break // Source (P Switch) on
            case 'P': extras[x+X*y]=PEACH; break // Peach starts unburned
            case 'B': extras[x+X*y]=BOWSER; break // Bowser starts unburned
            case '.':case'M':extras[x+X*y]=WALKABLE; break
            case '?': extras[x+X*y]=QUESTION; break
            default:  extras[x+X*y]=UNWALKABLE; break
          }
        }
      }
      //-------- GAMEPLAY: PRE-CONVERGE TO STEADY STATE PREVENT PREMATURE WIN
      if (preconverge) for (let iter=0; iter<preconverge; ++iter) evolve()
       //-------- GAMEPLAY: LOAD PEACHES AND BOWSERS AGAIN!!!! (UGLY HACK)
      for (let y=0; y<rows.length; ++y) {
        for (let x=0; x<rows[y].length && x<X; ++x) {
          switch (rows[y][x]) {
            case 'P': extras[x+X*y]=PEACH; ground[x+X*y]=0;break // Peach starts unburned
            case 'B': extras[x+X*y]=BOWSER;ground[x+X*y]=0; break // Bowser starts unburned
          }
        }
      }
      //-------- GAMEPLAY: IDENTIFY START POSITION
      for (let y=0; y<Y; ++y) for (let x=0; x<X; ++x) if (rows[y][x]=='M') {xCursor=x; yCursor=y}   
      xShaking=0;yShaking=0

      // for (let y=0; y<Y; ++y) {
      //   let s=''
      //   for (let x=0; x<X; ++x) {
      //     s+=ground[x+X*y]
      //   }
      //   console.log(s)
      // }
    }
    function setScaling() {
      winWid=window.innerWidth||document.documentElement.clientWidth||document.body.clientWidth
      winHei=window.innerHeight||document.documentElement.clientHeight||document.body.clientHeight
      let availWidth =clamp(winWid, 300, 1600) // set canvas width according to window width; warning: btnSize=48
      let availHeight=clamp(winHei*(1-.08), 300, 1200) // may reduce this
      cellsize=Math.min(Math.floor(availWidth/X),Math.floor((availHeight)/Y)) // for graphics
      canvas.width=X*cellsize
      canvas.height=Y*cellsize
      canvas.style.left =  Math.floor((winWid-canvas.width)/2) + "px"
      title.style.left = Math.floor((winWid-canvas.width)/2) + "px"
      title.style.width = canvas.width + "px"
    }
    async function resetGame() {
      tcur=0; xCursor=0; yCursor=0; winlose=PLAYING
      await loadLevel(levelMaps[level])
      setScaling()
      title.innerHTML = levelName
    }
    async function setLevel(newLevel) {
      if (newLevel<0||newLevel>=levelMaps.length) return // if new level number is illegal, don't load it
      level = newLevel
      btnPrev.disabled = (level==0)             // if current level is 0, disable "Previous Level" button
      btnNext.disabled = (level==levelMaps.length-1) // if we are on last level, disable "Next Level" button
      await resetGame()
    }
    async function prevLevel() {await setLevel(level-1)}
    async function nextLevel() {await setLevel(level+1)}

    function convertHtmlToText(htmlString) {
      const tempElement = document.createElement('div'); // Create a temporary, dummy element
      tempElement.innerHTML = htmlString; // Assign the HTML string to its innerHTML property
      return tempElement.textContent || tempElement.innerText || ""; // Retrieve the text content
    }
    function closeHelp() {helpDiv.style.display="none"}
    async function openHelp() {
        return //!!

      winWid=window.innerWidth||document.documentElement.clientWidth||document.body.clientWidth
      winHei=window.innerHeight||document.documentElement.clientHeight||document.body.clientHeight
      const wid=winWid - 64
      const hei=winHei - 64
      // const windowFeatures = `popup=true,width=${wid},height=${hei}`
      // console.log(windowFeatures)
      // let newWin = window.open('toadburnhelp.html', 'blankWindow', windowFeatures)
      // helpDiv.style.width = wid + "px"
      // helpDiv.style.height = hei + "px"
      // if (helpText.trim()=="MAIN") helpDiv.innerHTML = await fetch('toadburnhelp.html').then(r=>r.text())
      helpDiv.innerHTML = helpText
      helpDiv.onclick = closeHelp
      helpDiv.focus()
      helpDiv.style.display = "block"
      // console.log(helpText)
      // helpDiv.onkeydown = (e)=>{e.preventDefault();e.stopPropagation();helpDiv.style.visibility="hidden"}
      // if (newWin) {
      //   // newWin.document.write('<h1>Hello from the new window!</h1>')
      // }

      // let utterance = new SpeechSynthesisUtterance(convertHtmlToText(helpText))
      // utterance.pitch = 8.0
      // utterance.rate = 3.0
      // speechSynthesis.speak(utterance)
    }
    //===============================================
    // MAIN MODULE CODE
    //===============================================
    let winWid,winHei
    document.body.addEventListener('dblclick', function(e) { e.preventDefault() })
    const ctx=canvas.getContext('2d')

    //===============================================
    // Wait for ESSENTIAL resources to load
    //===============================================
    // const resources = await Promise.all([...imagePromises,...audioPromises])
    // let [imgMario,imgBowser,imgGrass,imgDirt,imgLava,imgCrying1,imgCrying2,imgHappy1,imgHappy2,
    //     imgStarOn,imgStarOff,
    //     audioTock,audioBuzz,audioWin,audioWin0] = resources
    let audioCoin = loadAudio('coin.mp3')
    let audioTock = loadAudio('tock.mp3')
    let audioBuzz = loadAudio('buzz.mp3')
    let audioWin0 = await loadAudio('win1.mp3')
    let audioWin1 = await loadAudio('win2.mp3')
    let audioLose = loadAudio('lose.mp3')
    let audioOof  = await loadAudio('oof.mp3')
    let audioOw   = await loadAudio('ow.mp3')

    let imgQuestion = await loadImage('question.webp')
    let imgMarioE = await loadImage('marioE.webp')
    let imgMarioW = await loadImage('marioW.webp')
    let imgMarioN = await loadImage('marioN.webp')
    let imgMarioS = await loadImage('marioS.webp')
    let animPeach = new Animation([await loadImage('peach1.webp'),await loadImage('peach2.webp')])
    let imgBowser = await loadImage('bowser.webp')
    let imgGrass = await loadImage('grass.webp')
    let imgDirt = await loadImage('dirt.webp') // dirt
    let imgLava = await loadImage('lava.webp')
    let imgLava2 = await loadImage('lava2.webp')
    let animLava = new Animation([imgLava,imgLava2])
    // let imgCrying1 = await loadImage('crying1.webp')
    // let imgCrying2 = await loadImage('crying2.webp')
    let animCrying = new Animation([await loadImage('crying1.webp'),await loadImage('crying2.webp')])
    let imgHappy1 = await loadImage('happy1.webp')
    let imgHappy2 = await loadImage('happy2.webp')
    let animHappy = new Animation([imgHappy1,imgHappy2])
    let imgStarOn = await loadImage('staron.webp')
    let imgStarOff = await loadImage('staroff.webp')
    let imgSourceOff = await loadImage('sourceoff.webp')
    let imgSourceOn = await loadImage('sourceon.webp')
    let levelMaps = await loadString('toadburnmaps.txt') // clear browser cache if this file is edited
    // TBD: do properly using Promise
    levelMaps = [...levelMaps.matchAll(  /<levelmap>.*?<\/levelmap>/gs )].map(i=>i[0])
    await setLevel(0)

canvas.style.display ="none"
    // splashScreen.style.display = "none"
    // controls.style.display = "block"
    
    document.body.addEventListener('keydown', keydown, false)
    btnReset.addEventListener('click', resetGame)
    btnPrev.addEventListener('click', prevLevel)
    btnNext.addEventListener('click', nextLevel)
    btnLeft.addEventListener('click', walkW)
    btnRight.addEventListener('click', walkE)
    btnUp.addEventListener('click', walkN)
    btnDown.addEventListener('click', walkS)
    // btnLeft.addEventListener('touchstart', walkW)
    // btnRight.addEventListener('touchstart', walkE)
    // btnUp.addEventListener('touchstart', walkN)
    // btnDown.addEventListener('touchstart', walkS)
    btnLava.addEventListener('click', placeLava)
    btnDirt.addEventListener('click', placeDirt)
    btnCross.addEventListener('click', placeSubway)
    btnGrass.addEventListener('click', placeGrass)
    btnToad.addEventListener('click', placeToad)
    btnSlow.addEventListener('click', goSlow)
    btnFast.addEventListener('click', goFast)
    btnCheat.addEventListener('click', enterCheatMode)
    window.addEventListener('resize', setScaling)

    // btnHelp.addEventListener('click', openHelp)
    openHelp()

    requestAnimationFrame(animate)
  </script>
</body>
</html> 