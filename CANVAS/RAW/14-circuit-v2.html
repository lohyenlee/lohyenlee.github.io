<!DOCTYPE html>
<html>
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    body {background-color: #111; padding: 0; margin: 0;}
    #instructions {
      float: left;
      padding: 4px; margin: 0px; position: absolute; bottom: 4em; width: 100%; z-index: 100; 
      background-color: #333; font-family: monospace; color: white;
    }
    .asdf {float: left; padding: 0; margin: 0px 20px 2px 2px; }
  </style>
</head>
<body>
  <script type="module">

    //=======================================
    //  MATH UTILITY FUNCTIONS
    //=======================================
    const clamp=(x,a,b) => Math.min(Math.max(x,a),b)
    //=================================================
    // SIMULATION STUFF
    //=================================================
    function addWire(x,y) { // Add cold holding wire at (x,y) if possible
      x=Math.floor(x/cellsize); if (x>=X) return
      y=Math.floor(y/cellsize); if (y>=Y) return
      cell[x + X*y] = 5 // cold holding
    }

    //=================================================
    // EVENT HANDLERS
    //=================================================
    function mousedown(e) {
      e.preventDefault()
      let x=e.offsetX, y=e.offsetY
      addWire(x,y); render()
    }
    function mousemove(e) {
      e.preventDefault()
    }
    function mouseup(e) {
      e.preventDefault()
    }
    function touchstart(e) {
      if (e.touches.length==2) return  ///{alert ("Double touch!"); return; }
      if (e.touches.length==1) e.preventDefault()
      let x=e.touches[0].pageX, y=e.touches[0].pageY
      addWire(x,y); render()
    }
    function touchmove(e) {
      e.preventDefault()
      let x=e.touches[0].pageX, y=e.touches[0].pageY
      addWire(x,y); render()
    }
    function touchend(e) {
      e.preventDefault()
    }

    function keydown(e) {
      let flag=true
      switch (e.key) {
        case 'ArrowRight':xcur+=1; break
        case 'ArrowLeft': xcur-=1; break
        case 'ArrowUp':   ycur-=1; break
        case 'ArrowDown': ycur+=1; break
        case 'Backspace':
        case 'Delete': cell[xcur+X*ycur] = 0; break
        case ' ':      cell[xcur+X*ycur] &= 0x0F; break  // regular
        case 'h':      cell[xcur+X*ycur] = 0x43; break  // source, hot, spreading
        case 'c':      cell[xcur+X*ycur] = 0x47; break  // source, cold, spreading
        case 'a':      cell[xcur+X*ycur] &= 0x0F; cell[xcur+X*ycur] |= 0x10; break 
        case 'b':      cell[xcur+X*ycur] &= 0x0F; cell[xcur+X*ycur] |= 0x20; break
        default: flag=false
      }
      if (e.shiftKey==true) cell[xcur+X*ycur] = 5 // cold holding`
      if (flag) {e.preventDefault(); e.stopPropagation()}
    }
    // function keyup(e) {
    //   if (e.key=='Shift') wiring=false
    // }
     function rgb(r, g, b){
      return ["rgb(",r,",",g,",",b,")"].join("");
    }
    function render() {
      ctx.clearRect(0, 0, canvas.width, canvas.height)
      ctx.fillStyle='#000'; ctx.fillRect(0,0, X*cellsize, Y*cellsize)
      ctx.lineWidth=2
      for (let x=0; x<X; ++x) for (let y=0; y<Y; ++y) {
        let i=x+X*y, c=cell[i]
        if (c) {
          switch(c&7) {
            case 3: ctx.fillStyle='#F33'; break
            case 2: ctx.fillStyle='#F66'; break
            case 1: ctx.fillStyle='#F99'; break
            case 7: ctx.fillStyle='#33F'; break
            case 6: ctx.fillStyle='#66F'; break
            case 5: ctx.fillStyle='#99F'; break
          }
          ctx.fillRect(x*cellsize, y*cellsize, cellsize, cellsize)
          switch(c&0x30) {
            case 0x10: ctx.strokeStyle='#0C0'; ctx.strokeRect(x*cellsize, y*cellsize, cellsize, cellsize); break
            case 0x20: ctx.strokeStyle='#CC0'; ctx.strokeRect(x*cellsize, y*cellsize, cellsize, cellsize); break
          }
        }
      }
      tcur += 1
      let asdf = (tcur%60<30) ? 255:0;
      ctx.strokeStyle=rgb(asdf,asdf,asdf)
      ctx.strokeRect(xcur*cellsize, ycur*cellsize, cellsize, cellsize)
    }
    
    function evolve(x,y) {
      let c=cell[x+X*y]
      const E=cell[(x-1)+X*y]
      const W=cell[(x+1)+X*y]
      const N=cell[x+X*(y+1)]
      const S=cell[x+X*(y-1)]
      if (c&0x40) { //========= Sources do not decay
      }
      else if (c&0x10) { 
        //======== A-block. Accept pulses from any block except B-block
        switch(c&7) {
          case 3: c&=0xF0; c|=2; break
          case 2: c&=0xF0; c|=1; break
          case 7: c&=0xF0; c|=6; break
          case 6: c&=0xF0; c|=5; break
          case 1:
          case 5:
            if ((E&0x27)==3 || (W&0x27)==3 || (N&0x27)==3 || (S&0x27)==3) {c&=0xF0; c|=3}
            if ((E&0x27)==7 || (W&0x27)==7 || (N&0x27)==7 || (S&0x27)==7) {c&=0xF0; c|=7}
            break
        }
      } 
      else if (c&0x20) { 
        //======== B-block. Accept pulses only from A-block?
        switch(c&7) {
          case 3: c&=0xF0; c|=2; break
          case 2: c&=0xF0; c|=1; break
          case 7: c&=0xF0; c|=6; break
          case 6: c&=0xF0; c|=5; break
          case 1:
          case 5:
            if ((E&0x17)==0x13 || (W&0x17)==0x13 || (N&0x17)==0x13 || (S&0x17)==0x13) {c&=0xF0; c|=3}
            if ((E&0x17)==0x17 || (W&0x17)==0x17 || (N&0x17)==0x17 || (S&0x17)==0x17) {c&=0xF0; c|=7}
            break
        }
      } 
      else { 
        //========= Regular
        switch(c&7) {
          case 3: c&=0xF0; c|=2; break
          case 2: c&=0xF0; c|=1; break
          case 7: c&=0xF0; c|=6; break
          case 6: c&=0xF0; c|=5; break
          case 1:
          case 5:
            if ((E&7)==3 || (W&7)==3 || (N&7)==3 || (S&7)==3) {c&=0xF0; c|=3}
            if ((E&7)==7 || (W&7)==7 || (N&7)==7 || (S&7)==7) {c&=0xF0; c|=7}
            break
        }
      }
      cellNew[x+X*y] = c
    }

    function animate(timeCurrent) {
      for (let y=0; y<Y; ++y) for (let x=0; x<X; ++x) evolve(x,y)
      for (let y=0; y<Y; ++y) for (let x=0; x<X; ++x) cell[x+X*y]=cellNew[x+X*y]
      render()
      requestAnimationFrame(animate)
    }

    //===============================================
    // MAIN CODE
    //===============================================
    document.body.addEventListener("dblclick", function(e) { e.preventDefault() })
    const winWid = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth
    const winHei = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight
    const canvas = document.createElement("canvas")
    canvas.width  = clamp(winWid-8, 300, 800) // set canvas width according to window width
    canvas.height = clamp(winHei-8, 300, 800)
    canvas.style.background = "#CCC"
    const ctx = canvas.getContext("2d")
    // ctx.font = "10px Arial"
    
    const cellsize=32
    const X = Math.floor(canvas.width/cellsize)
    const Y = Math.floor(canvas.height/cellsize) - 10
    canvas.width = X*cellsize
    canvas.height = Y*cellsize
    let xcur=1,ycur=1
    let tcur=0
    //let xcur = Math.floor(X/2),ycur=Math.floor(Y/2)
    const cell = new Int8Array(X*Y)
    const cellNew = new Int8Array(X*Y)
    for (let x=0; x<X; ++x) for (let y=0; y<Y; ++y) cell[x+X*y]=0

    const map = `
  .......A
         B............
  .......A
    `.split('\n')
    for (let y=0; y<map.length; ++y) {
      for (let x=0; x<map[y].length; ++x) {
        switch (map[y][x]) {
          case ' ': cell[x+X*y]=0; break
          case '.': cell[x+X*y]=5; break
          case '0': case '1': case '2': case '3': case '5': case '6': case '7':
            cell[x+X*y]=map[y][x]-'0'; break
          case '1': cell[x+X*y]=1; break
          case 'H': cell[x+X*y]=0x43; break
          case 'C': cell[x+X*y]=0x47; break
          case 'A': cell[x+X*y]=0x15; break
          case 'B': cell[x+X*y]=0x25; break
        }
      }
    }
 
    document.body.insertBefore(canvas, document.body.childNodes[0])
    canvas.addEventListener("touchstart", touchstart, false)
    canvas.addEventListener("touchmove", touchmove, false)
    canvas.addEventListener("touchend", touchend, false)
    canvas.addEventListener("mousedown", mousedown, false)
    canvas.addEventListener("mousemove", mousemove, false)
    canvas.addEventListener("mouseup", mouseup, false)
    document.body.addEventListener("keydown", keydown, false)
    // keyup///
    render()
    requestAnimationFrame(animate)

  </script>
  <div id="instructions">
    <div class="asdf"> &#8592;&#8593;&#8595;&#8594;  Move cursor </div>
    <div class="asdf"> Shift=Wire </div>
    <div class="asdf"> H=Hot source </div>
    <div class="asdf"> C=Cold source </div>
    <div class="asdf"> A=Diode start </div>
    <div class="asdf"> B=Diode end </div>
  </div>

    <!--
CELLULAR AUTOMATON

Let x=0,...,X-1 and y=0,...,Y-1 be coordinates.
Let s(x,y)=0,...,0xFF be cell cell.
At every timestep, update all sites synchronously.

Bits 3-0  DESCRIPTION      UPDATE RULE
--------  -----------      ------------
0         Empty            Don't update
3         Hot spreading    Decay to 2
2         Hot decaying     Decay to 1
1         Hot holding      If (any neighbor=3) this=3; if (any neighbor=7) this=7
7         Cold spreading   Decay to 6
6         Cold decaying    Decay to 5
5         Cold holding    If (any neighbor=3) this=3; if (any neighbor=7) this=7

Bits 7-4  DESCRIPTION      UPDATE RULE
-------- -----------      ------------
0001      Upstream         Does not accept hot/cold spreading from Downstream node
0010      Downstream       No special rule
0100      Source           Bits 2-0: update 1->3 or 5>7 
-->
</body>
</html>

