<!DOCTYPE html>
<html>
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="icon" href="favicon.ico" type="image/x-icon">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Titillium+Web:wght@700&display=swap" rel="stylesheet">
  <style>
    body {background-color: #000; padding: 0px; margin: 0;}
    .asdf {float: left; padding: 0; margin: 0px 20px 2px 2px; }   
    .button1 {
      width: 21%; margin: 0; padding: 0; text-align: center; 
      border-radius: 8px;/* border-style: outset; */
      font-family: 'Titillium Web',sans-serif; font-size: 3vmin; background: #666; color: white;
    }
  </style>
</head>
<body>
  <script type="module">
    //================================
    // SOUND 
    // https://curtisrobinson.medium.com/how-to-auto-play-audio-in-safari-with-javascript-21d50b0a2765
    //================================
    const audioContext = new (window.AudioContext || window.webkitAudioContext)()
    function loadSound(filename) {
      let sound = { volume: 1, audioBuffer: null }
      let ajax = new XMLHttpRequest()
      ajax.open("GET", filename, true)
      ajax.responseType = "arraybuffer"
      ajax.onload = function () {
        audioContext.decodeAudioData(
          ajax.response,
          function (buffer) { sound.audioBuffer = buffer },
          function (error) { debugger }
        )
      }
      ajax.onerror = function () { debugger }
      ajax.send()
      return sound
    }
    function playSound(sound) {
      if (!sound.audioBuffer) return false
      const source = audioContext.createBufferSource()
      if (!source) return false
      source.buffer = sound.audioBuffer
      if (!source.start) source.start = source.noteOn
      if (!source.start) return false
      const gainNode = audioContext.createGain()
      gainNode.gain.value = sound.volume
      source.connect(gainNode)
      gainNode.connect(audioContext.destination)
      source.start(0)
      sound.gainNode = gainNode
      return true
    }
    function stopSound(sound) {
      if (sound.gainNode) sound.gainNode.gain.value = 0
    }
    function setSoundVolume(sound, volume) {
      sound.volume = volume
      if (sound.gainNode) sound.gainNode.gain.value = volume
    }

    //================================
    // PRELOAD AND PREPARE SOUNDS AND TEXTURES 
    //================================
    // const soundDing = loadSound("ding.mp3")
    const soundTock = loadSound("tock.mp3")
    const soundBuzz = loadSound("buzz.ogg")
    const soundWin = loadSound("win.mp3")
    const soundWin0 = loadSound("smb_bowserfalls.wav")
    // const soundWin = loadSound("dingling.mp3")

    //=======================================
    // APPLET OPTIONS
    //=======================================
    const levelStrings=[`
uuuuuuuuuuuuuuuuuuu
uuuuuuuuuuuuuuuuuuu
uuu
uuu  ........ ...
uuu  .      . . .
uuu... ...... . .
uuu    .      . .
uuu    ........ F
uuu
uuuuuuuuuuuuuuuuuuu
uuuuuuuuuuuuuuuuuuu
`,`
uuuuuuuuuuuuuuuuuuu
uuuuuuuuuuuuuuuuuuu
uuu
uuu
uuu7....
uuu    G......F
uuu7....
uuu
uuu
uuu
uuuuuuuuuuuuuuuuuuu
uuuuuuuuuuuuuuuuuuu
`,`
uuuuuuuuuuuuuuuuuuuuuu
uuuuuuuuuuuuuuuuuuuuuu
uuu
uuu
uuu    ......
uuu7....    G......F
uuu    ......
uuu
uuu
uuu
uuuuuuuuuuuuuuuuuuuuuu
uuuuuuuuuuuuuuuuuuuuuu
`,`
uuuuuuuuuuuuuuuuuuuuuuuuuuu
uuuuuuuuuuuuuuuuuuuuuuu33uu
uuuuuuuuuuuuuuuuuuuuuu3333u
uu                 uuu333uu
uuu7...            uuuu33uu
uuu   G.....       uuuuuuuu
uuu7...    .         uuuuuu
uuu        G....     uuuuuu
uuu7...    .   .      uuuuu
uuu   G.....   G.F     uuuu
uuu1...       ..      uuuuu
uuu           .    uuuuuuuu
uuu7...........    uuuuuuuu
uu                 uuuuuuuu
uuuuuuuuuuuuuuuuuuuuuuuuuuu
uuuuuuuuuuuuuuuuuuuuuuuuuuu
uuuuuuuuuuuuuuuuuuuuuuuuuuu
`,`
uuuuuuuuuuuuuuuuuuuuuuuuuuu
uuuuuuuuuuuuuuuuuuuuuuuuuuu
uuuuuuuuuuuuuuuuuuuuuuuuuuu
uu                 uuuuuuuu
uuu ...G....       uuuuuuu
uuu .      .        uuuuuuuu
uuu ........          uuuuuu
uuu        .          uuuuuu
uuu        G.....F   uuuuuu
uuu        .         uuu
uuu7........          uuuu
uu                 uuuuuuuu
uuuuuuuuuuuuuuuuuuuuuuuuuuu
uuuuuuuuuuuuuuuuuuuuuuuuuuu
uuuuuuuuuuuuuuuuuuuuuuuuuuu`
    ]
    const fillStyles='#000 #44F #55F #66F #00F #F44 #F55 #F66 #F00'.split(' ') // color scheme for various cell states
    // const fillStyles='0 #444 #555 #666 0 #F65 #F6E #F66'.split(' ') // color scheme for various cell states
    const ALLOWED=0
    const FORBIDDEN=1
    const FLAG=127
    
    //=================================================
    // SIMULATION
    //=================================================
    function evolve(x,y) {
      let c=cell[x+X*y]
      const E=cell[(x+1)+X*y]
      const W=cell[(x-1)+X*y]
      const N=cell[x+X*(y-1)]
      const S=cell[x+X*(y+1)]
      if (c&0x10) {  // c is an output cell ...... TBD!!!!
      }
      else if (W==4)      {c=1}  // copy state from gate at west
      else if (W==8) {c=7}  // copy state from gate at west
      else {
        switch(c) {
          case 7: c=6; break // hot burning -> hot burned
          case 6: c=5; break // hot burned -> hot dormant
          case 1: c=2; break // cold burning -> cold burned
          case 2: c=3; break // cold burning -> cold dormant
          case 3: case 5: // cold dormant or hot dormant
            if ((E&7)==1 || (W&7)==1 || (N&7)==1 || (S&7)==1) c=1
            if ((E&7)==7 || (W&7)==7 || (N&7)==7 || (S&7)==7) c=7
            break
          case 4: case 8: // current cell is a GATE
            if (  (W&7)>4 || (N&7)>4 || (S&7)>4 ) c=4
            else                                  c=8
        }
      }
      cellNew[x+X*y] = c
    }
    function evolveAll() {
      for (let y=0; y<Y; ++y) for (let x=0; x<X; ++x) evolve(x,y)                // evolve
      for (let y=0; y<Y; ++y) for (let x=0; x<X; ++x) cell[x+X*y]=cellNew[x+X*y] // synchronous update
    }
    
    //=================================================
    // GRAPHICS
    //=================================================
    async function loadImage(url) { return new Promise(r => { let i=new Image(); i.onload=(()=>r(i)); i.src=url; }); }
    let imgMario = await loadImage('mario64.png')
    let imgBowser = await loadImage('bowser64.png')
    let imgGrass = await loadImage('grass.webp')
    let imgWater = await loadImage('water.webp')
    let imgLava = await loadImage('lava.webp')
    let imgToadCrying = await loadImage('toadcrying64.webp')
    let imgToadHappy = await loadImage('toadhappy64.webp')
    let bowserX=0,bowserY=0
  
    const clamp=(x,a,b) => Math.min(Math.max(x,a),b)
    function rgb(r,g,b) {return ["rgb(",r,",",g,",",b,")"].join("");}
    function xyBoard(x,y) {return[Math.floor(x/cellsize),Math.floor(y/cellsize)]}
    function xyScreen(x,y) {return[x*cellsize,y*cellsize]} // top left corner
    function fillSquare(x,y) {ctx.fillRect(x*cellsize, y*cellsize, cellsize, cellsize)}
    // function strokeSquare(x,y) {ctx.strokeRect(x*cellsize, y*cellsize, cellsize, cellsize)}
    function drawNOR(x,y) {
      ctx.strokeStyle='#FF0'; ctx.fillStyle='#FF0'
      let r=cellsize/2,a=x*cellsize,b=y*cellsize
      ctx.beginPath()
      ctx.arc(a+r, b+r, r, -Math.PI/2, Math.PI/2)
      ctx.moveTo(a+r,b); ctx.lineTo(a,b); ctx.lineTo(a,b+r+r); ctx.lineTo(a+r,b+r+r)
      ctx.stroke()
      ctx.fillText('NOR', x*cellsize+2, (y+.5)*cellsize)
    }
    function render() {
      ctx.clearRect(0, 0, canvas.width, canvas.height)
      ctx.fillStyle='#000'; 
      ctx.strokeStyle='#FFF'; 
      ctx.fillRect(0,0, X*cellsize, Y*cellsize)
      ctx.strokeRect(0,0, X*cellsize, Y*cellsize)
      //======== INDICATE UNLOCKED CELLS BY GREEN BACKGROUND
      for (let y=0; y<Y; ++y) for (let x=0; x<X; ++x) if (access[x+X*y]==ALLOWED) {
         ctx.drawImage(imgGrass, x*cellsize, y*cellsize, cellsize, cellsize)
      }
      //======== DRAW CIRCUIT
      ctx.lineWidth=2; ctx.font = '10px Arial'
      for (let y=0; y<Y; ++y) for (let x=0; x<X; ++x) {
        let i=x+X*y, c=cell[i]
        switch(c) {
          case 1: case 2: case 3: 
            // ctx.fillStyle=fillStyles[c]; fillSquare(x,y); break
            ctx.drawImage(imgWater, x*cellsize, y*cellsize, cellsize, cellsize)
            break
          case 5: case 6: case 7: 
            //ctx.fillStyle=fillStyles[c]; fillSquare(x,y)
            ctx.drawImage(imgLava, x*cellsize, y*cellsize, cellsize, cellsize)
            break
          case 4: // at least one input is HIGH, output is LOW
            // ctx.fillStyle=fillStyles[4]; fillSquare(x,y)
            ctx.drawImage(imgWater, x*cellsize, y*cellsize, cellsize, cellsize)
            ctx.drawImage(imgToadHappy, x*cellsize, y*cellsize, cellsize, cellsize)
            //drawNOR(x,y); 
            break
          case 8:  // both inputs are LOW, output is HIGH (?)
            ctx.fillStyle=fillStyles[8]; fillSquare(x,y)
            ctx.drawImage(imgLava, x*cellsize, y*cellsize, cellsize, cellsize)
            ctx.drawImage(imgToadCrying, x*cellsize, y*cellsize, cellsize, cellsize)
            //drawNOR(x,y); 
            break
        }
      }
      //======== DRAW BOWSER
      if (won) {
        if (tcur<100) {bowserX+=Math.cos(tcur*.6)*2; bowserY=Math.sin(tcur*.3)*10 }
        else {bowserX=0; bowserY += (tcur-20)*.03}
      }
      for (let y=0; y<Y; ++y) for (let x=0; x<X; ++x) if (access[x+X*y]==FLAG) {
        ctx.drawImage(imgBowser, x*cellsize+bowserX, y*cellsize+bowserY, cellsize, cellsize)
      }
      //======== DRAW MARIO
      tcur += 1
      ctx.drawImage(imgMario, xcur*cellsize, ycur*cellsize, cellsize*3/4, cellsize) // note Mario's aspect ratio
    }

    let won = false
    let timeOfLastFrame = 0
    function animate(timeCurrent) {
      // Check victory condition
      if (won==false) {   
        for (let y=0; y<Y; ++y) for (let x=0; x<X; ++x) {
          if (access[x+X*y]==FLAG && cell[x+X*y]>4) {won=true; break}
        }
        if (won==true) win()
      }      

      requestAnimationFrame(animate)
      render()

      let elapsed = Date.now() - timeOfLastFrame
      if (elapsed <= 100) return
      timeOfLastFrame = Date.now()

      evolveAll()
    }
    //=================================================
    // EVENT HANDLERS
    //=================================================
    let penType=0;
    function tryMove(xnew,ynew) {
      if (xnew<0||xnew>=X||ynew<0||ynew>=Y||access[xnew+X*ynew]!=ALLOWED) {reportIllegalMove(); return 0}
      xcur=xnew; ycur=ynew; return 1
    }
    function reportIllegalMove() {playSound(soundBuzz)}
    function win() {
      playSound(soundWin0);
      tcur=0
      setTimeout(  () => {playSound(soundWin)}   , 1000)
  }
    // function mousedown(e) {
    //   e.preventDefault()
    //   const [x,y]=xyBoard(e.offsetX,e.offsetY)
    //   if (!tryMove(x,y)) return        // check that we can go to destination
    //   if      (cell[x+X*y]==0)  penType=1    // paint cold active
    //   else if (cell[x+X*y]<4)   penType=7    // paint hot active
    //   else                      penType=0
    //   cell[x+X*y]=penType
    //   playSound(soundTock)
    // }
    // function mousemove(e) {
    //   e.preventDefault()
    //   const [x,y]=xyBoard(e.offsetX,e.offsetY)
    //   if (!tryMove(x,y)) return
    //   cell[x+X*y]=penType
    // }
    // function touchstart(e) {
    //   e.preventDefault()
    //   const [x,y]=xyBoard(e.touches[0].pageX,e.touches[0].pageY)
    //   if (!tryMove(x,y)) return        // check that we can go to destination
    //   console.log(x,y,cell[x+X*y])
    //   if      (cell[x+X*y]==0)  penType=1    // paint cold active
    //   else if (cell[x+X*y]<4)   penType=7    // paint hot active
    //   else                      penType=0
    //   cell[x+X*y]=penType
    //   playSound(soundTock)
    // }
    // function touchmove(e) {
    //   e.preventDefault()
    //   const [x,y]=xyBoard(e.touches[0].pageX,e.touches[0].pageY)
    //   if (!tryMove(x,y)) return
    //   cell[x+X*y]=penType
    // }
    function keydown(e) {
      let processed=true
      switch (e.key) {
        case 'ArrowRight':case 'l': tryMove(xcur+1,ycur); break // move cursor
        case 'ArrowLeft': case 'j': tryMove(xcur-1,ycur); break
        case 'ArrowUp':   case 'i': tryMove(xcur,ycur-1); break
        case 'ArrowDown': case 'k': tryMove(xcur,ycur+1); break
        case 'Backspace': case 'Delete': cell[xcur+X*ycur] = 0; break // erase current cell
        case ' ': 
          if      (cell[xcur+X*ycur]==0) cell[xcur+X*ycur]=1 // cold active
          else if (cell[xcur+X*ycur]<4)  cell[xcur+X*ycur]=7 // hot active
          else                           cell[xcur+X*ycur]=0
          playSound(soundTock)
          break
        case '2': cell[xcur+X*ycur] = 7; break    // add hot burning
        case '1': cell[xcur+X*ycur] = 1; break    // add cold burning
        case 'o': cell[xcur+X*ycur] = 0x13; break // add output cell 
        default: processed=false
      }
      if (e.shiftKey==true) cell[xcur+X*ycur] = 5 // add cold dormant
      if (processed) {e.preventDefault(); e.stopPropagation();
      }
    }

    //===============================================
    // GAMEPLAY
    //===============================================
    let level,tcur,X,Y      // current level, current time, current level size
    let cell,cellNew,access // X*Y arrays
    let cellsize // cell size in pixels
    let xcur,ycur // cursor position

    function loadMap(mapStr) {
      //-------- DETERMINE MAP SIZE AND ALLOCATE ARRAYS
      const mapLines = mapStr.split('\n').filter(item=>item)
      X = Math.max(...mapLines.map(str => str.length) )
      Y = mapLines.length
      cellsize = Math.min(Math.floor(canvas.width/X),Math.floor((canvas.height-32)/Y))
      cell = new Int8Array(X*Y)
      cellNew = new Int8Array(X*Y)
      access = new Int8Array(X*Y)
      bowserX=0;bowserY=0
      //-------- POPULATE ARRAYS
      for (let y=0; y<Y; ++y) for (let x=0; x<X; ++x) cell[x+X*y]=0   // START WITH ALL CELLS EMPTY
      for (let y=0; y<Y; ++y) for (let x=0; x<X; ++x) access[x+X*y]=FORBIDDEN // START WITH ALL CELLS LOCKED

      for (let y=0; y<mapLines.length; ++y) {
        for (let x=0; x<mapLines[y].length && x<X; ++x) {
          switch (mapLines[y][x]) {
            case ' ': cell[x+X*y]=0; break
            case '.': cell[x+X*y]=3; break
            case '1': case '2': case '3': case '5': case '6': case '7':
              cell[x+X*y]=mapLines[y][x]-'0'; break
            case '1': cell[x+X*y]=1; break
            case 'G': cell[x+X*y]=4; break
            case 'F': cell[x+X*y]=3; access[x+X*y]=FLAG; break
            case 'u': access[x+X*y]=0; break  // unlock
          }
        }
      }
      //-------- ITERATE AND CONVERGE...
      for (let iter=0; iter<1000; ++iter) evolveAll()
    }
    function resetGame() {tcur=0; xcur=1; ycur=1; won=false; loadMap(levelStrings[level]) }
    function setLevel(newLevel) { // adjust buttons to prevent going to levels that don't exist
      level = newLevel
      document.querySelector('#prevLevelButton').disabled = (level==0)
      document.querySelector('#nextLevelButton').disabled = (level==levelStrings.length - 1)
    }
    function prevLevel() {if (level <= 0) return; setLevel(level-1); resetGame() }
    function nextLevel() {if (level>=levelStrings.length-1) return; setLevel(level+1); resetGame(); }

    //===============================================
    // MAIN CODE
    //===============================================
    document.body.addEventListener('dblclick', function(e) { e.preventDefault() })
    const winWid = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth
    const winHei = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight
    const canvas = document.createElement("canvas")
    canvas.width  = clamp(winWid, 300, 1600) // set canvas width according to window width
    canvas.height = clamp(winHei-64, 300, 800)
    canvas.style.background = '#000'
    const ctx = canvas.getContext('2d')
  
    // const X = Math.floor(canvas.width/cellsize)
    // const Y = Math.floor(canvas.height/cellsize)
    // canvas.width = X*cellsize
    // canvas.height = Y*cellsize
    
    //setLevel(0); resetGame()
    setLevel(4); resetGame()
 
    document.body.insertBefore(canvas, document.body.childNodes[0])
    // canvas.addEventListener("touchstart", touchstart, false)
    // canvas.addEventListener("touchmove", touchmove, false) // no need touchend and mouseup for now
    // canvas.addEventListener("mousedown", mousedown, false)
    // canvas.addEventListener("mousemove", mousemove, false)
    document.body.addEventListener('keydown', keydown, false)
    document.querySelector('#resetButton').addEventListener('click', resetGame);
    document.querySelector('#prevLevelButton').addEventListener('click', prevLevel);
    document.querySelector('#nextLevelButton').addEventListener('click', nextLevel);

    requestAnimationFrame(animate)





  </script>
  <div id="instructions"
    style="float: left; padding: 0; margin: 0; position: absolute;  bottom: 1em; width: 80%; text-align: center;
      font-family: 'Titillium Web',sans-serif; font-size: 3vmin; color: white;">
    &#8592;&#8593;&#8595;&#8594; or IJKL: move    
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  Space: grass/water/lava
  </div>
  <div id="controls"
    style="font-size: 4vmin; position: absolute; bottom: 2em; width: 80%; text-align: center;">
    <button id="prevLevelButton" class="button1"> Previous level </button>
    <button id="resetButton" class="button1">Reset</button>
    <button id="nextLevelButton" class="button1"> Next level </button>
  </div>
</body>
</html>

