<!DOCTYPE html>
<html>
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    body {background-color: #000; padding: 0px; margin: 0;}
    #instructions {
      float: left;
      padding: 0; margin: 0; position: absolute; left: 1em; bottom: 1em; width: calc(100%-32px); z-index: 100; 
      background-color: #333; font-family: monospace; color: white;
    }
    .asdf {float: left; padding: 0; margin: 0px 20px 2px 2px; }
  </style>
</head>
<body>
  <script type="module">
    //================================
    // SOUND 
    // https://curtisrobinson.medium.com/how-to-auto-play-audio-in-safari-with-javascript-21d50b0a2765
    //================================
    const audioContext = new (window.AudioContext || window.webkitAudioContext)()
    function loadSound(filename) {
      let sound = { volume: 1, audioBuffer: null }
      let ajax = new XMLHttpRequest()
      ajax.open("GET", filename, true)
      ajax.responseType = "arraybuffer"
      ajax.onload = function () {
        audioContext.decodeAudioData(
          ajax.response,
          function (buffer) { sound.audioBuffer = buffer },
          function (error) { debugger }
        )
      }
      ajax.onerror = function () { debugger }
      ajax.send()
      return sound
    }
    function playSound(sound) {
      if (!sound.audioBuffer) return false
      const source = audioContext.createBufferSource()
      if (!source) return false
      source.buffer = sound.audioBuffer
      if (!source.start) source.start = source.noteOn
      if (!source.start) return false
      const gainNode = audioContext.createGain()
      gainNode.gain.value = sound.volume
      source.connect(gainNode)
      gainNode.connect(audioContext.destination)
      source.start(0)
      sound.gainNode = gainNode
      return true
    }
    function stopSound(sound) {
      if (sound.gainNode) sound.gainNode.gain.value = 0
    }
    function setSoundVolume(sound, volume) {
      sound.volume = volume
      if (sound.gainNode) sound.gainNode.gain.value = volume
    }

    //================================
    // PRELOAD AND PREPARE SOUNDS AND TEXTURES 
    //================================
    const soundDing = loadSound("ding.mp3")
    const soundTock = loadSound("tock.mp3")
    const soundWin = loadSound("win.mp3")

    //=======================================
    // APPLET OPTIONS (FEEL FREE TO CHANGE THESE)
    //=======================================
    const cellsize=32 // cell size in pixels
    let xcur=1,ycur=1 // starting cursor position
    const map=`
uuuuuuuuuuuuuuuuuuuuu
uuuuuuuuuuuuuuuuuuuuuu
uuuuuuuuuuuuuuuuuuuuuuu
uu                 uuuu
uuu1...            uuuu
uu    G.....       uuuu
uuu7...    .         uu
uu         G....     uu
uuu7...    .   .      uuu
uu    G.....   G.F     uuuu
uuu1...       ..      uu
uu            .    uuuuu
uuu7...........    uuuuu
uu                 uuuuu
uuuuuuuuuuuuuuuuuuuuuuuu
uuuuuuuuuuuuuuuuuuuuuuu
uuuuuuuuuuuuuuuuuuuuu
    `.split('\n').slice(1)    // map
    const fillStyles='#000 #44F #55F #66F #00F #F44 #F55 #F66 #F00'.split(' ') // color scheme for various cell states
    // const fillStyles='0 #444 #555 #666 0 #F65 #F6E #F66'.split(' ') // color scheme for various cell states
    const FLAG=127
    
    //=================================================
    // SIMULATION
    //=================================================
    function evolve(x,y) {
      let c=cell[x+X*y]
      const E=cell[(x+1)+X*y]
      const W=cell[(x-1)+X*y]
      const N=cell[x+X*(y-1)]
      const S=cell[x+X*(y+1)]
      if (c&0x10) {  // c is an output cell
      }
      else if (W==4)      {c=1}  // copy state from gate at west
      else if (W==8) {c=7}  // copy state from gate at west
      else {
        switch(c) {
          case 7: c=6; break // hot burning -> hot burned
          case 6: c=5; break // hot burned -> hot dormant
          case 1: c=2; break // cold burning -> cold burned
          case 2: c=3; break // cold burning -> cold dormant
          case 3: case 5: // cold dormant or hot dormant
            if ((E&7)==1 || (W&7)==1 || (N&7)==1 || (S&7)==1) c=1
            if ((E&7)==7 || (W&7)==7 || (N&7)==7 || (S&7)==7) c=7
            break
          case 4: case 8: // current cell is a GATE
            if (  (W&7)>4 || (N&7)>4 || (S&7)>4 ) c=4
            else                                  c=8
        }
      }
      cellNew[x+X*y] = c
    }

    
    //=================================================
    // GRAPHICS
    //=================================================
    const clamp=(x,a,b) => Math.min(Math.max(x,a),b)
    function rgb(r,g,b) {return ["rgb(",r,",",g,",",b,")"].join("");}
    function xyBoard(x,y) {return[Math.floor(x/cellsize),Math.floor(y/cellsize)]}
    function xyScreen(x,y) {return[x*cellsize,y*cellsize]} // top left corner
    function fillSquare(x,y) {ctx.fillRect(x*cellsize, y*cellsize, cellsize, cellsize)}
    function strokeSquare(x,y) {ctx.strokeRect(x*cellsize, y*cellsize, cellsize, cellsize)}
    function drawNAND(x,y) {
      ctx.strokeStyle='#FF0'; ctx.fillStyle='#FF0'
      let r=cellsize/2,a=x*cellsize,b=y*cellsize
      ctx.beginPath()
      ctx.arc(a+r, b+r, r, -Math.PI/2, Math.PI/2)
      ctx.moveTo(a+r,b); ctx.lineTo(a,b); ctx.lineTo(a,b+r+r); ctx.lineTo(a+r,b+r+r)
      ctx.stroke()
      ctx.fillText('NAND', x*cellsize+2, (y+.5)*cellsize)
    }
    function render() {
      //ctx.clearRect(0, 0, canvas.width, canvas.height)
      ctx.fillStyle='#000'; 
      ctx.strokeStyle='#FFF'; 
      ctx.fillRect(0,0, X*cellsize, Y*cellsize)
      ctx.strokeRect(0,0, X*cellsize, Y*cellsize)

 
       //======== INDICATE UNLOCKED CELLS BY GREEN BACKGROUND
      for (let y=0; y<Y; ++y) for (let x=0; x<X; ++x) {
        if (locked[x+X*y]==0)         {ctx.fillStyle='#6F66'; fillSquare(x,y)}
        else if (locked[x+X*y]==FLAG) {ctx.fillStyle='#FFF'; ctx.fillText('FLAG', x*cellsize+2, (y+.5)*cellsize); }
      }

      //======== DRAW CIRCUIT
      ctx.lineWidth=2; ctx.font = '10px Arial'
      for (let y=0; y<Y; ++y) for (let x=0; x<X; ++x) {
        let i=x+X*y, c=cell[i]
        switch(c) {
          case 1: case 2: case 3: case 5: case 6: case 7: ctx.fillStyle=fillStyles[c]; fillSquare(x,y); break
          case 4: ctx.fillStyle=fillStyles[4]; fillSquare(x,y); drawNAND(x,y); break
          case 8: ctx.fillStyle=fillStyles[8]; fillSquare(x,y); drawNAND(x,y); break
        }
      }
      //======== Draw cursor
      tcur += 1
      let a = (tcur%40<20) ? 0xFF:0x99; ctx.strokeStyle=rgb(a,a,a); strokeSquare(xcur,ycur)
    }
    function animate(timeCurrent) {
      for (let y=0; y<Y; ++y) for (let x=0; x<X; ++x) evolve(x,y)                // evolve
      for (let y=0; y<Y; ++y) for (let x=0; x<X; ++x) cell[x+X*y]=cellNew[x+X*y] // synchronous update
      render(); requestAnimationFrame(animate)
    }
    //=================================================
    // EVENT HANDLERS
    //=================================================
    let penType=0;
    function tryMove(xnew,ynew) {
      if (xnew<0||xnew>=X||ynew<0||ynew>=Y||locked[xnew+X*ynew]==1) {reportIllegalMove(); return 0}
      xcur=xnew; ycur=ynew; return 1
    }
    function reportIllegalMove() {
       playSound(soundTock);
    }
    function win() {
       playSound(soundwin);
    }
    function mousedown(e) {
      e.preventDefault()
      const [x,y]=xyBoard(e.offsetX,e.offsetY)
      if (!tryMove(x,y)) return        // check that we can go to destination
      if      (cell[x+X*y]==0)  penType=1    // paint cold active
      else if (cell[x+X*y]<4)   penType=7    // paint hot active
      else                      penType=0
      cell[x+X*y]=penType
      playSound(soundDing)
    }
    function mousemove(e) {
      e.preventDefault()
      const [x,y]=xyBoard(e.offsetX,e.offsetY)
      if (!tryMove(x,y)) return
      cell[x+X*y]=penType
    }
    function mouseup(e) {
      e.preventDefault()
    }
    function touchstart(e) {
      e.preventDefault()
      const [x,y]=xyBoard(e.touches[0].pageX,e.touches[0].pageY)
      if (!tryMove(x,y)) return        // check that we can go to destination
      console.log(x,y,cell[x+X*y])
      if      (cell[x+X*y]==0)  penType=1    // paint cold active
      else if (cell[x+X*y]<4)   penType=7    // paint hot active
      else                      penType=0
      cell[x+X*y]=penType
      playSound(soundDing)
    }
    function touchmove(e) {
      e.preventDefault()
      const [x,y]=xyBoard(e.touches[0].pageX,e.touches[0].pageY)
      if (!tryMove(x,y)) return
      cell[x+X*y]=penType
    }
    function touchend(e) {
      e.preventDefault()
    }

    function keydown(e) {
      let processed=true
      switch (e.key) {
        case 'ArrowRight':tryMove(xcur+1,ycur); break // move cursor
        case 'ArrowLeft': tryMove(xcur-1,ycur); break
        case 'ArrowUp':   tryMove(xcur,ycur-1); break
        case 'ArrowDown': tryMove(xcur,ycur+1); break
        case 'Backspace': case 'Delete': cell[xcur+X*ycur] = 0; break // erase current cell
        case ' ': 
          if      (cell[xcur+X*ycur]==0) cell[xcur+X*ycur]=1 // cold active
          else if (cell[xcur+X*ycur]<4)  cell[xcur+X*ycur]=7 // hot active
          else                           cell[xcur+X*ycur]=0
          playSound(soundDing)
          break
        case '2': cell[xcur+X*ycur] = 7; break    // add hot burning
        case '1': cell[xcur+X*ycur] = 1; break    // add cold burning
        case 'o': cell[xcur+X*ycur] = 0x13; break // add output cell 
        default: processed=false
      }
      if (e.shiftKey==true) cell[xcur+X*ycur] = 5 // add cold dormant
      if (processed) {e.preventDefault(); e.stopPropagation();
      }
    }



    //===============================================
    // MAIN CODE
    //===============================================
    document.body.addEventListener("dblclick", function(e) { e.preventDefault() })
    const winWid = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth
    const winHei = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight
    const canvas = document.createElement("canvas")
    canvas.width  = clamp(winWid, 300, 800) // set canvas width according to window width
    canvas.height = clamp(winHei, 300, 800)
    canvas.style.background = "#CCC"
    const ctx = canvas.getContext("2d")
    
    const X = Math.floor(canvas.width/cellsize)
    const Y = Math.floor(canvas.height/cellsize)
    canvas.width = X*cellsize
    canvas.height = Y*cellsize
    let tcur=0
    //let xcur = Math.floor(X/2),ycur=Math.floor(Y/2)
    const cell = new Int8Array(X*Y)
    const cellNew = new Int8Array(X*Y)
    const locked = new Int8Array(X*Y)
    for (let y=0; y<Y; ++y) for (let x=0; x<X; ++x) cell[x+X*y]=0   // START WITH ALL CELLS EMPTY
    for (let y=0; y<Y; ++y) for (let x=0; x<X; ++x) locked[x+X*y]=1 // START WITH ALL CELLS LOCKED

    for (let y=0; y<map.length; ++y) {
      for (let x=0; x<map[y].length && x<X; ++x) {
        switch (map[y][x]) {
          case ' ': cell[x+X*y]=0; break
          case '.': cell[x+X*y]=3; break
          case '1': case '2': case '3': case '5': case '6': case '7':
            cell[x+X*y]=map[y][x]-'0'; break
          case '1': cell[x+X*y]=1; break
          case 'G': cell[x+X*y]=4; break
          case 'F': cell[x+X*y]=3; locked[x+X*y]=FLAG; break
          case 'u': locked[x+X*y]=0; break  // unlock
        }
      }
    }
 
    document.body.insertBefore(canvas, document.body.childNodes[0])
    canvas.addEventListener("touchstart", touchstart, false)
    canvas.addEventListener("touchmove", touchmove, false)
    canvas.addEventListener("touchend", touchend, false)
    canvas.addEventListener("mousedown", mousedown, false)
    canvas.addEventListener("mousemove", mousemove, false)
    canvas.addEventListener("mouseup", mouseup, false)
    document.body.addEventListener("keydown", keydown, false)
    // keyup///
    render()
    requestAnimationFrame(animate)

  </script>
  <div id="instructions">
    <div class="asdf"> &#8592;&#8593;&#8595;&#8594;=move </div>
    <div class="asdf"> Spacebar=toggle </div>
    <!-- <div class="asdf"> Shift=Wire </div> -->
  </div>
</body>
</html>

