<!DOCTYPE html>
<html>
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="icon" href="favicon.ico" type="image/x-icon">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Titillium+Web:wght@700&display=swap" rel="stylesheet">
  <style>
    body {background-color:#333; padding:0; margin:0;}
    .asdf {float:left; padding:0; margin: 0px 20px 2px 2px; }   
    :root {--btnsize:48px;}
    .button1 {
      float:left;width:var(--btnsize); height:var(--btnsize); margin:0; padding:0; text-align:center; 
      border-radius:8px; font-family:'Titillium Web',sans-serif; font-size:3vmin; background:#666; color:white;
    }
    .button2 {
      float:left;width:100%;margin:0; padding:0; text-align:center; 
      border-radius:8px; font-family:'Titillium Web',sans-serif; font-size:3vmin; background:#666; color:white;
    }
  </style>
</head>
<body>
  <div class="container">
    <canvas id="canvas" style="position:absolute; top:0; left:150px;">Your browser does not support the HTML5 canvas tag.</canvas>
  </div>
  <div id="mapNameplate"
    style="float:left; padding:0; margin:0; position:absolute; top:2px; width:100%; text-align:center;
      font-family:'Titillium Web',sans-serif; font-size:3vmin; color:white;">
  </div>
  <div id="controls" style="font-size:4vmin; position:absolute; top:0; left:0; text-align:center;">
    <button id="btnPrev" class="button2"  style="clear:left;"> Previous [ </button>
    <div style="height: 8px; clear:left;"></div>
    <button id="btnReset" class="button2" style="clear:left;"> Reset R </button>
    <div style="height: 8px; clear:left;"></div>
    <button id="btnNext" class="button2"  style="clear:left;"> Next ] </button>
    <!-- separator --><div style="height:32px; clear:left;"> </div>
    <button id="btnSlow" class="button2">Slow</button>
    <button id="btnFast" class="button2">Fast</button>
    <!-- separator --><div style="height:32px; clear:left;"> </div>
    <button id="btnLava" class="button1" style="background-image:url(lava.webp);background-size:cover;"> U </button>
    <button id="btnUp" class="button1" style="background-image:url(arrowU.svg);background-size:cover;"> I </button>
    <button id="btnWater" class="button1" style="background-image:url(water.webp);">O</button>
    <br/>
    <button id="btnLeft" class="button1" style="background-image:url(arrowL.svg);background-size:cover;"> J </button>
    <button id="btnCross" class="button1"> K </button>
    <button id="btnRight" class="button1" style="background-image:url(arrowR.svg);background-size: 300px 100px;background-size:cover;"> L </button>
    <br/>
    <button id="btnToad" class="button1" style="background-image:url(happy1.webp);background-size:cover;">M</button>
    <button id="btnDown" class="button1" style="background-image:url(arrowD.svg);background-size:cover;"> &lt; </button>
    <button id="btnGrass" class="button1" style="background-image:url(grass.webp);"> &gt; </button>
  </div>
  <div id="instructions"
    style="float:left; padding:0; margin:0; position:absolute; bottom:1em; width:80%; text-align:center;
      font-family:'Titillium Web',sans-serif; font-size:2vmin; color:white;">
    Move Mario using &#8592;&#8593;&#8595;&#8594; or IJKL.  Place lava, water, toad, or grass using 1,2,3,4 or U,O,M,&gt;
    Press Shift-C to enter cheat mode.
  </div>
  <script type="module">


    //=========================================
    // RESOURCES: loadSound() and loadImage()
    //=========================================
    const audioContext=new(window.AudioContext||window.webkitAudioContext)()
    function loadSound(filename) {
      let sound={volume:1,audioBuffer:null}
      let ajax=new XMLHttpRequest()
      ajax.open("GET", filename, true)
      ajax.responseType="arraybuffer"
      ajax.onload = function () {
        audioContext.decodeAudioData(
          ajax.response,
          function(buf) {sound.audioBuffer=buf},
          function(err) {debugger}
        )
      }
      ajax.onerror = function() {debugger}
      ajax.send()
      return sound
    }
    function playSound(sound) {
      if (!sound.audioBuffer) return false
      const source = audioContext.createBufferSource()
      if (!source) return false
      source.buffer = sound.audioBuffer
      if (!source.start) source.start = source.noteOn
      if (!source.start) return false
      const gainNode = audioContext.createGain()
      gainNode.gain.value = sound.volume
      source.connect(gainNode)
      gainNode.connect(audioContext.destination)
      source.start(0)
      sound.gainNode = gainNode
      return true
    }
    function stopSound(sound) {if(sound.gainNode) sound.gainNode.gain.value=0}
    function setSoundVolume(sound,vol) {sound.volume=vol; if(sound.gainNode) sound.gainNode.gain.value=vol}
    async function loadImage(url) { return new Promise(r => { let i=new Image(); i.onload=(()=>r(i)); i.src=url; }); }
    //================================
    // PRELOAD AND PREPARE SOUNDS AND TEXTURES 
    //================================
    const soundTock = loadSound("tock.mp3")
    const soundBuzz = loadSound("buzz.ogg")
    const soundWin = loadSound("win.mp3")
    const soundWin0 = loadSound("smb_bowserfalls.wav")
    let imgMario = await loadImage('mario64.png')
    let imgBowser = await loadImage('bowser64.png')
    let imgGrass = await loadImage('grass.webp')
    let imgWater = await loadImage('water.webp')
    let imgLava = await loadImage('lava.webp')
    let imgCrying1 = await loadImage('crying1.webp')
    let imgCrying2 = await loadImage('crying2.webp')
    let imgHappy1 = await loadImage('happy1.webp')
    let imgHappy2 = await loadImage('happy2.webp')
    let imgStarOn = await loadImage('staron.webp')
    let imgStarOff = await loadImage('staroff.webp')
    function loadString(url) {return fetch(url).then( r => r.text() ) }
    let maps = await loadString('toadBurnMaps.txt') // clear browser cache if this file is edited
    // TBD: figure out how to use await
    //const mapStrings = maps.split(/#* NEWLEVEL #*[\s\S]/)  //).slice(1)
    const mapStrings = maps.split(/<newlevel>[\s\S]/)  //).slice(1)
    // console.log(mapStrings)
    // console.log(mapStrings[0])
    
    //=======================================
    // APPLET OPTIONS
    //=======================================
    const ALLOWED=0
    const FORBIDDEN=1
    const GOAL=127
    const LAMP=2
    //===============================================
    // GLOBAL VARIABLES
    //===============================================
    let timeStepInMilliseconds = 100
    let X,Y
    let ground,groundNew // X*Y arrays
    let subway,subwayNew // X*Y arrays
    //===============================================
    // GLOBAL VARIABLES: GAMEPLAY AND EYECANDY
    //===============================================
    let level,mapName,tcur   // current level, ... current time
    let access // X*Y arrays
    let cellsize // ground size in pixels
    let xcur,ycur // cursor position
    let bowserX=0,bowserY=0

    //===============================================
    // evolve(): EVOLVE CELLULAR AUTOMATON
    // Reads global variables: X,Y,ground,subway
    // Writes contents of:     ground,subway
    //===============================================
    function evolve() {
      for (let y=0; y<Y; ++y) for (let x=0; x<X; ++x) {
        //======== Consider ground-level state
        let C=ground[x+X*y]
        //======== Get states of East and West neighbors
        const E=ground[(x+1)+X*y]
        const W=ground[(x-1)+X*y]
        //======== If current location has an interchange, then ground level has NO N and S neighbors
        let N,S;
        if (subway[x+X*y]) {N=0; S=0}
        else {
          //======== If North neighbor is an interchange, use the subway value; otherwise use ground value
          N=subway[x+X*(y-1)]; if(N==0) N=ground[x+X*(y-1)]
          S=subway[x+X*(y+1)]; if(S==0) S=ground[x+X*(y+1)]
        }
        //======== Update ground-level state 
        if (W==4)      {C=1}  // copy state from gate at west
        else if (W==8) {C=7}  // copy state from gate at west
        else {
          switch(C) {
            case 7: C=6; break // hot burning -> hot burned
            case 6: C=5; break // hot burned -> hot dormant
            case 1: C=2; break // cold burning -> cold burned
            case 2: C=3; break // cold burning -> cold dormant
            case 3: case 5: // cold dormant or hot dormant
              if ((E&7)==1 || (W&7)==1 || (N&7)==1 || (S&7)==1) C=1
              if ((E&7)==7 || (W&7)==7 || (N&7)==7 || (S&7)==7) C=7
              break
            case 4: case 8: // current ground is a NOR GATE
              if (  (W&7)>4 || (N&7)>4 || (S&7)>4 ) C=4
              else                                  C=8
          }
        }
        groundNew[x+X*y] = C
        //======== Update subway-level state (based on N and S only)
        C=subway[x+X*y]
        switch(C) {
          case 0: break      // not an interchange
          case 7: C=6; break // hot burning -> hot burned
          case 6: C=5; break // hot burned -> hot dormant
          case 1: C=2; break // cold burning -> cold burned
          case 2: C=3; break // cold burning -> cold dormant
          case 3: case 5: // cold dormant or hot dormant
            N=ground[x+X*(y-1)]
            S=ground[x+X*(y+1)]
            if ((N&7)==1 || (S&7)==1) C=1
            if ((N&7)==7 || (S&7)==7) C=7
            break
        }
        subwayNew[x+X*y] = C
      } 
      for (let y=0; y<Y; ++y) for (let x=0; x<X; ++x) ground[x+X*y]=groundNew[x+X*y] // synchronous update
      for (let y=0; y<Y; ++y) for (let x=0; x<X; ++x) subway[x+X*y]=subwayNew[x+X*y] // synchronous update
    }

    //=================================================
    // GRAPHICS
    //=================================================
    const clamp=(x,a,b) => Math.min(Math.max(x,a),b)
    function rgb(r,g,b) {return ["rgb(",r,",",g,",",b,")"].join("");}
    function xyBoard(x,y) {return[Math.floor(x/cellsize),Math.floor(y/cellsize)]}
    function xyScreen(x,y) {return[x*cellsize,y*cellsize]} // top left corner

    function render() {
      const h=cellsize
      //======== DRAW BACKGROUND AND GAME AREA
      ctx.clearRect(0, 0, canvas.width, canvas.height)
      ctx.fillStyle='#000';   ctx.fillRect(0,0, X*h, Y*h)
      //======== INDICATE ACCESSIBLE CELLS BY GREEN BACKGROUND
      for (let y=0; y<Y; ++y) for (let x=0; x<X; ++x) if (access[x+X*y]==ALLOWED) {
         ctx.drawImage(imgGrass, x*h, y*h, h, h)
      }
      //======== DRAW CIRCUIT
      ctx.lineWidth=2 //; ctx.font = '10px Arial'
      for (let y=0; y<Y; ++y) for (let x=0; x<X; ++x) {
        let i=x+X*y, c=ground[i]
        if (c==0) continue
        switch(c) {
          case 1: case 2: case 3: 
            ctx.drawImage(imgWater, x*h, y*h, h, h)
            break
          case 5: case 6: case 7: 
            ctx.drawImage(imgLava, x*h, y*h, h, h)
            break
          case 4: // at least one input is HIGH, output is LOW
            ctx.drawImage(imgWater, x*h, y*h, h, h)
            if (ground[(x-1)+X*y]>4) ctx.drawImage(imgLava, 0,0,32,64, x*h,y*h,h/2,h)
            if (ground[x+X*(y-1)]>4) ctx.drawImage(imgLava, 0,0,64,32, x*h,y*h,h,h/2)
            if (ground[x+X*(y+1)]>4) ctx.drawImage(imgLava, 0,32,64,32, x*h,y*h+h/2,h,h/2)
            ctx.drawImage((Math.floor(tcur/10)%2)?imgCrying1:imgCrying2, x*h,y*h,h,h)
            break
          case 8:  // both inputs are LOW, output is HIGH (?)
            ctx.drawImage(imgWater, x*h, y*h, h, h)
            ctx.drawImage((Math.floor(tcur/12)%2)?imgHappy1:imgHappy2, x*h,y*h,h,h)
            break
        }
        if (subway[x+X*y]>0) { // draw interchange as "bridge"
          ctx.fillStyle='#964B00' // brown wood bridge
          ctx.fillRect(x*h,y*h, h,4)
          ctx.fillRect(x*h,y*h+h-4, h,4)
        }
      }
      //======== DRAW SPECIAL OBJECTS THAT NEED TO BE ON TOP     
      for (let y=0; y<Y; ++y) for (let x=0; x<X; ++x) {
        if (access[x+X*y]==LAMP) { // draw "lamp"
          if (ground[x+X*y]>4) {
            if ((Math.floor(tcur/10)%2)) {
              ctx.drawImage(imgStarOn, x*h-24, y*h-24, h+48, h+48)
            } else {
              ctx.drawImage(imgStarOn, x*h-20, y*h-20, h+40, h+40)
            }
          }
          else ctx.drawImage(imgStarOff, x*h-20, y*h-20, h+40, h+40)
        }
      }
      //======== DRAW BOWSER
      if (won) {
        if (tcur<100) {bowserX+=Math.cos(tcur*.6)*2; bowserY=Math.sin(tcur*.3)*10 }
        else {bowserX=0; bowserY += (tcur-20)*.03}
      }
      for (let y=0; y<Y; ++y) for (let x=0; x<X; ++x) if (access[x+X*y]==GOAL) {
        ctx.drawImage(imgBowser, x*h+bowserX-.5*h, y*h+bowserY-.5*h, h *2, h *2)
      }
      //======== DRAW MARIO
      tcur += 1
      ctx.drawImage(imgMario, xcur*h, ycur*h, h*3/4, h) // note Mario's aspect ratio
      //======== DRAW FRAME AROUND GAME AREA
      ctx.strokeStyle='#FFF'; ctx.strokeRect(0,0, X*h, Y*h)
    }

    let won = false
    let timeOfLastFrame = 0
    function animate(timeCurrent) {
      // Check victory condition
      if (won==false) {   
        for (let y=0; y<Y; ++y) for (let x=0; x<X; ++x) {
          if (access[x+X*y]==GOAL && ground[x+X*y]>4) {won=true; break}
        }
        if (won==true) win()
      }      

      requestAnimationFrame(animate)
      render()

      let elapsed = Date.now() - timeOfLastFrame
      if (elapsed <= timeStepInMilliseconds) return
      timeOfLastFrame = Date.now()

      evolve()
    }
    //=================================================
    // EVENT HANDLERS
    //=================================================
    let penType=0;
    function tryMove(xnew,ynew) {
      if (xnew<0||xnew>=X||ynew<0||ynew>=Y||access[xnew+X*ynew]!=ALLOWED) {reportIllegalMove(); return 0}
      xcur=xnew; ycur=ynew; playSound(soundTock); return 1
    }
    function reportIllegalMove() {playSound(soundBuzz)}
    function win() {
      playSound(soundWin0);
      tcur=0
      setTimeout(  () => {playSound(soundWin)}   , 1000)
    }
    function goLeft()  {tryMove(xcur-1,ycur);}
    function goRight() {tryMove(xcur+1,ycur);}
    function goUp()    {tryMove(xcur,ycur-1);}
    function goDown()  {tryMove(xcur,ycur+1);}
    function placeLava()  {ground[xcur+X*ycur]=7; playSound(soundTock);}
    function placeWater() {ground[xcur+X*ycur]=1; playSound(soundTock);}
    function placeGrass() {ground[xcur+X*ycur]=0; playSound(soundTock);}
    function placeToad()  {ground[xcur+X*ycur]=4; playSound(soundTock);}
    function goSlow()  {timeStepInMilliseconds=100;}
    function goFast()  {timeStepInMilliseconds=1;}
    
    function keydown(e) {
      if (e.ctrlKey||e.altKey) return // don't trap browser shortcuts involving Ctrl or Alt
      let processed=true
      switch (e.key) {
        case '[': setLevel(level-1); break
        case ']': setLevel(level+1); break
        case 'ArrowRight':case 'l': tryMove(xcur+1,ycur); break // move cursor
        case 'ArrowLeft': case 'j': tryMove(xcur-1,ycur); break
        case 'ArrowUp':   case 'i': tryMove(xcur,ycur-1); break
        case 'ArrowDown': case ',': tryMove(xcur,ycur+1); break
        case ' ': 
          if      (ground[xcur+X*ycur]==0) ground[xcur+X*ycur]=1 // cold active
          else if (ground[xcur+X*ycur]<4)  ground[xcur+X*ycur]=7 // hot active
          else                           ground[xcur+X*ycur]=0
          playSound(soundTock)
          break
        case '.':case '`': case 'Backspace': case 'Delete': 
                          placeGrass(); break // erase current ground
        case 'u':case'1': placeLava(); break    // add hot burning
        case 'o':case'2': placeWater(); break    // add cold burning
        case 'm':case'3': placeToad(); break    // add NOR gate (Toad)
        case 'x':case 'k': if(subway[xcur+X*ycur]) subway[xcur+X*ycur]=0; else subway[xcur+X*ycur]=3; break // toggle interchange
        case 'C': for(let y=0;y<Y;++y)for(let x=0;x<X;++x)access[x+X*y]=ALLOWED; break    // CHEAT TO GET ACCESS TO EVERYTHING
        case 'R': resetGame(); break    // reset level
        default: processed=false
      }
//      if (e.shiftKey==true) ground[xcur+X*ycur] = 3 // add cold dormant
      if (processed) {e.preventDefault(); e.stopPropagation(); }
    }


    //===============================================
    // loadMap()
    // Writes global X,Y,ground,groundNew,subway,subwayNew
    // printMap()
    // Reads global X,Y,ground
    //===============================================
    function loadMap(str) {
      //-------- DETERMINE MAP SIZE AND ALLOCATE ARRAYS
      // console.log(str)
      let rows = str.split(/[\r\n]/).filter(s=>s)
      mapName = rows[0]; rows=rows.slice(1)       // not sure about syntax
      X = Math.max(...rows.map(s=>s.length))     // length of longest line
      Y = rows.length
      ground   =new Int8Array(X*Y)
      groundNew=new Int8Array(X*Y)
      subway   =new Int8Array(X*Y)
      subwayNew=new Int8Array(X*Y)
      //-------- POPULATE ARRAYS
      for (let y=0; y<Y; ++y) for (let x=0; x<X; ++x) {
        ground[x+X*y]=0   // START WITH BARE GROUND    
        subway[x+X*y]=0   // START WITH NO INTERCHANGES 
      }
      for (let y=0; y<rows.length; ++y) {
        for (let x=0; x<rows[y].length && x<X; ++x) {
          switch (rows[y][x]) {
            case '.': case 'â–ˆ': case '#': ground[x+X*y]=3; break
            case '1': case '2': case '3': case '5': case '6': case '7': ground[x+X*y]=rows[y][x]-'0'; break
            case 'G': ground[x+X*y]=4; break // NOR gate
            case '+': ground[x+X*y]=3; subway[x+X*y]=3; break // interchange
            case ' ': case 'u': default: ground[x+X*y]=0; break
          }
        }
      }

      //-------- GAMEPLAY: ALSO LOAD "ACCESS"
      access=new Int8Array(X*Y) // for mario moving
      for (let y=0; y<Y; ++y) for (let x=0; x<X; ++x) access[x+X*y]=FORBIDDEN
      for (let y=0; y<rows.length; ++y) {
        for (let x=0; x<rows[y].length && x<X; ++x) {
          switch (rows[y][x]) {
            case 'L': access[x+X*y]=LAMP; ground[x+X*y]=3; break // Lamp
            case 'F': access[x+X*y]=GOAL; ground[x+X*y]=3; break // Bowser starts unburned
            case 'u': access[x+X*y]=ALLOWED; break
            default:  access[x+X*y]=FORBIDDEN; break
          }
        }
      }
      //-------- GAMEPLAY: PRE-CONVERGE TO STEADY STATE PREVENT PREMATURE WIN
      if (level>0) 
        for (let iter=0; iter<1000; ++iter) evolve()
      bowserX=0;bowserY=0
    }
    function resetGame() {
      tcur=0; xcur=1; ycur=1; won=false; loadMap(mapStrings[level])
      let availWidth =clamp(winWid-3*50, 300, 1600) // set canvas width according to window width; warning: btnSize=48
      let availHeight=clamp(winHei-0, 300, 800)
      cellsize=Math.min(Math.floor(availWidth/X),Math.floor((availHeight)/Y)) // for graphics
      canvas.width=X*cellsize
      canvas.height=Y*cellsize
      mapNameplate.innerHTML = mapName
    }
    function setLevel(newLevel) {
      if (newLevel<0||newLevel>=mapStrings.length) return // can't load illegal level
      level=newLevel
      // disable any buttons that need to be disabled
      btnPrev.disabled = (level==0)
      btnNext.disabled = (level==mapStrings.length-1)
      resetGame()
    }
    function prevLevel() {setLevel(level-1)}
    function nextLevel() {setLevel(level+1)}

    //===============================================
    // MAIN CODE
    //===============================================
    document.body.addEventListener('dblclick', function(e) { e.preventDefault() })
    const winWid=window.innerWidth||document.documentElement.clientWidth||document.body.clientWidth
    const winHei=window.innerHeight||document.documentElement.clientHeight||document.body.clientHeight
    // const canvas=document.createElement("canvas")
    // canvas.style.left = "200px;"
    //const canvas = myCanvas
    
    const ctx=canvas.getContext('2d')
    setLevel(0); resetGame()
 
    document.body.insertBefore(canvas, document.body.childNodes[0])
    document.body.addEventListener('keydown', keydown, false)
    btnReset.addEventListener('click', resetGame)
    btnPrev.addEventListener('click', prevLevel)
    btnNext.addEventListener('click', nextLevel)
    btnLeft.addEventListener('click', goLeft)
    btnRight.addEventListener('click', goRight)
    btnUp.addEventListener('click', goUp)
    btnDown.addEventListener('click', goDown)
    btnLava.addEventListener('click', placeLava)
    btnWater.addEventListener('click', placeWater)
    btnGrass.addEventListener('click', placeGrass)
    btnToad.addEventListener('click', placeToad)
    btnSlow.addEventListener('click', goSlow)
    btnFast.addEventListener('click', goFast)
    requestAnimationFrame(animate)
  </script>
</body>
</html>